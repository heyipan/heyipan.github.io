var Tokenizer = require("./Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

require("util").inherits(Parser, require("events").EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= 0 initialoffset){ this.startindex="0;" } else { - initialoffset; + 1; this.endindex="this._tokenizer.getAbsoluteIndex();" }; tokenizer event handlers parser.prototype.ontext="function(data){" this._updateposition(1); this.endindex--; if(this._cbs.ontext) this._cbs.ontext(data); parser.prototype.onopentagname="function(name){" if(this._lowercasetagnames){ name="name.toLowerCase();" this._tagname="name;" if(!this._options.xmlmode && in openimpliesclose) for( var el; (el="this._stack[this._stack.length" 1]) openimpliesclose[name]; this.onclosetag(el) ); if(this._options.xmlmode || !(name voidelements)){ this._stack.push(name); if(this._cbs.onopentagname) this._cbs.onopentagname(name); if(this._cbs.onopentag) this._attribs="{};" parser.prototype.onopentagend="function(){" if(this._attribs){ this._cbs.onopentag(this._tagname, this._attribs); this._cbs.onclosetag voidelements){ this._cbs.onclosetag(this._tagname); ; parser.prototype.onclosetag="function(name){" if(this._stack.length (!(name voidelements) this._options.xmlmode)){ pos="this._stack.lastIndexOf(name);" if(pos !="=" -1){ if(this._cbs.onclosetag){ pos; while(pos--) this._cbs.onclosetag(this._stack.pop()); this._stack.length="pos;" if(name="==" "p" !this._options.xmlmode){ this.onopentagname(name); this._closecurrenttag(); (name="==" "br" "p")){ parser.prototype.onselfclosingtag="function(){" this._options.recognizeselfclosing){ this.onopentagend(); parser.prototype._closecurrenttag="function(){" self-closing tags will be on the top of stack (cheaper check than onclosetag) if(this._stack[this._stack.length 1]="==" name){ this._cbs.onclosetag(name); this._stack.pop(); parser.prototype.onattribname="function(name){" if(this._lowercaseattributenames){ this._attribname="name;" parser.prototype.onattribdata="function(value){" this._attribvalue parser.prototype.onattribend="function(){" if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue); if( !object.prototype.hasownproperty.call(this._attribs, this._attribname) ){ this._attribs[this._attribname]="this._attribvalue;" parser.prototype._getinstructionname="function(value){" idx="value.search(re_nameEnd)," < ? value : value.substr(0, idx); return name; parser.prototype.ondeclaration="function(value){" if(this._cbs.onprocessinginstruction){ this._cbs.onprocessinginstruction("!" name, "!" value); parser.prototype.onprocessinginstruction="function(value){" this._cbs.onprocessinginstruction("?" "?" parser.prototype.oncomment="function(value){" this._updateposition(4); if(this._cbs.oncomment) this._cbs.oncomment(value); if(this._cbs.oncommentend) this._cbs.oncommentend(); parser.prototype.oncdata="function(value){" this._options.recognizecdata){ if(this._cbs.oncdatastart) this._cbs.oncdatastart(); this._cbs.ontext(value); if(this._cbs.oncdataend) this._cbs.oncdataend(); this.oncomment("[cdata[" "]]"); parser.prototype.onerror="function(err){" if(this._cbs.onerror) this._cbs.onerror(err); parser.prototype.onend="function(){" i="this._stack.length;"> 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;
</=>