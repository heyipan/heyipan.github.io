<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jenkins前端自动部署入门</title>
      <link href="/2019/12/06/2019/11/jenkins%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/"/>
      <url>/2019/12/06/2019/11/jenkins%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="jenkins前端自动部署入门"><a href="#jenkins前端自动部署入门" class="headerlink" title="jenkins前端自动部署入门"></a>jenkins前端自动部署入门</h2><p>由于前端项目打包后是静态资源，不需要进程守护。一般地，前端项目使用jenkins来进行自动部署，包括打包、测试等一系列流程</p><p>由于 jenkins是基于java环境运行的，所以首先需要安装java环境</p><p>参考：<br><a href="https://jingyan.baidu.com/article/375c8e190c1f9525f2a22931.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/375c8e190c1f9525f2a22931.html</a></p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>1、下载地址：<a href="https://jenkins.io/download，" target="_blank" rel="noopener">https://jenkins.io/download，</a></p><p>下载最后war包, 下载完成后进入下载后的目录，在<code>cmd</code>中输入 <code>java -jar jenkins.war</code> 然后在页面输入<code>localhost:8080</code></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>　　启动jenkins服务后，可以在8080端口访问到jenkins<br><img src="https://pic.xiaohuochai.site/blog/jenkins1.png" alt></p><p>然后在服务器的指定目录找到密码登录</p><p>/var/lib/jenkins/secrets/initialAdminPassword</p><p>按照默认配置安装插件 </p><p><img src="https://pic.xiaohuochai.site/blog/jenkins2.png" alt></p><p>等待插件安装完成</p><p><img src="https://pic.xiaohuochai.site/blog/jenkins3.png" alt></p><p>创建一个管理员账户，完成配置后，就可以登录 Jenkins 了</p><p><img src="https://pic.xiaohuochai.site/blog/jenkins4.png" alt></p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>下面来安装nodejs插件<br><img src="https://pic.xiaohuochai.site/blog/jenkins6.png" alt></p><p>可以看到，Jenkins提供了丰富的插件供开发者使用，找到需要的[NodeJS Plugin]，勾选后点击安装即可</p><p><img src="https://pic.xiaohuochai.site/blog/jenkins7.png" alt></p><blockquote><p>可能会出现网络不好或者被墙的情况，可以换一下域（百度一下）</p></blockquote><h4 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h4><ol><li>安装好github钩子以及nodejs插件后，接下来开始配置任务</li></ol><p>　　点击创建一个新任务，填写任务名称，构建的项目类型可根据实际情况进行选择，本次选择第一种即可<br>　　<br><img src="https://pic.xiaohuochai.site/blog/jenkins5.png" alt></p><ol start="2"><li>配置基础信息</li></ol><p><img src="https://pic.xiaohuochai.site/blog/jenkins12.png" alt></p><ol start="3"><li><p>往下拉，看到源码管理，点选Git，依然填写博客对应的Repo地址<br><img src="https://pic.xiaohuochai.site/blog/jenkins13.png" alt></p></li><li><p>继续往下拉，在构建触发器单击增加构建步骤，在弹出的下拉菜单中选择<code>Execute shell。勾选GitHub hook trigger for GITScm polling</code>。构建环境选择nodejs</p></li></ol><p><img src="https://pic.xiaohuochai.site/blog/jenkins14.png" alt></p><ol start="5"><li>构建过程<br>一般地，构建过程，输入如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &amp;&amp;</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure></li></ol><h3 id="问题处理："><a href="#问题处理：" class="headerlink" title="问题处理："></a>问题处理：</h3><ol><li><p>假如证书有问题的话会报错：<br><img src="https://img2018.cnblogs.com/blog/1406304/201905/1406304-20190527105223189-1051377169.png" alt><br>可以点击：  <a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><p>滑动到最后，配置修改地址，将https改成http，</p></li></ol><p><a href="http://updates.jenkins.io/update-center.json" target="_blank" rel="noopener">http://updates.jenkins.io/update-center.json</a></p><p>或者</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><p>然后点击submit-&gt;checknow</p><ol start="2"><li>插件管理页面提示：There were errors <code>checking the update sites:IOException:Unable to tunnel through proxy.Proxy returins &quot;HTTP/1.1 400&quot;</code><br><img src="https://img2018.cnblogs.com/blog/1406304/201905/1406304-20190524095823763-636781851.png" alt><br>解决办法和第一个是一样的。</li></ol><p>参考文档：</p><ul><li><a href="https://blog.csdn.net/lykio_881210/article/details/88557728" target="_blank" rel="noopener">Jenkins+GitHub集成接口测试环境部署</a></li><li><a href="https://www.cnblogs.com/grey-wolf/p/8716662.html" target="_blank" rel="noopener">jenkins实战（一）：war安装及插件安装</a></li><li><a href="https://www.cnblogs.com/imyalost/p/8677345.html" target="_blank" rel="noopener">jenkins简单安装及配置（Windows环境）</a></li><li><a href="https://blog.csdn.net/GISuuser/article/details/100121237" target="_blank" rel="noopener">Jenkins安装与插件安装连接超时问题</a></li><li><a href="https://blog.csdn.net/u011922006/article/details/88187060" target="_blank" rel="noopener">jenkins+github集成自动化测试环境搭建（1）-jenkins和github安装</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decorator装饰器 学习笔记</title>
      <link href="/2019/11/22/2019/11/Decorator%E8%A3%85%E9%A5%B0%E5%99%A8%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/22/2019/11/Decorator%E8%A3%85%E9%A5%B0%E5%99%A8%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器分类"><a href="#装饰器分类" class="headerlink" title="装饰器分类"></a>装饰器分类</h2><p>Decorator装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@frozen </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。所以个人理解：<br>装饰器分为<strong>类装饰器</strong>和<strong>类属性</strong>装饰器</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>顾名思义是用来装饰整个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable // true</span><br></pre></td></tr></table></figure><p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p><p>基本上，装饰器的行为就是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>testable</code>函数的参数<code>target</code>，就是会被装饰的类。</p><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function testable(isTestable) &#123;</span><br><span class="line">  return function(target) &#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(true)</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br><span class="line"></span><br><span class="line">@testable(false)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">MyClass.isTestable // false</span><br></pre></td></tr></table></figure><p>装饰器testable可以接受参数，这就等于可以修改装饰器的行为。</p><blockquote><p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p></blockquote><h3 id="类属性装饰器"><a href="#类属性装饰器" class="headerlink" title="类属性装饰器"></a>类属性装饰器</h3><p>装饰器不仅可以装饰类，还可以装饰类的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  age=18;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰器readonly用来装饰“类”的name方法和age属性。</p><p>实现readonly装饰器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">  // descriptor对象原来的值如下</span><br><span class="line">  // &#123;</span><br><span class="line">  //   value: specifiedFunction, //对象属性的默认值，默认值为undefined</span><br><span class="line">  //   enumerable: false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true</span><br><span class="line">  //   configurable: true,//能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true</span><br><span class="line">  //   writable: true,//对象属性是否可修改,flase为不可修改，默认值为true</span><br><span class="line">  // &#125;;</span><br><span class="line">  descriptor.writable = false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, &apos;name&apos;, descriptor);</span><br><span class="line">// 类似于</span><br><span class="line">Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor);</span><br></pre></td></tr></table></figure><p>类属性装饰器参数：</p><ul><li>第一个参数是类的<strong>原型对象</strong>，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；</li><li>第二个参数是所要装饰的属性名，</li><li>第三个参数是该属性的描述对象。</li></ul><p>上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><h3 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a>装饰器执行顺序</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'evaluated'</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'executed'</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec1(<span class="number">2</span>)</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1-调用这个类的所有方法的时候-都要输出日志"><a href="#练习1-调用这个类的所有方法的时候-都要输出日志" class="headerlink" title="练习1 调用这个类的所有方法的时候  都要输出日志"></a>练习1 调用这个类的所有方法的时候  都要输出日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function log(terget)&#123;</span><br><span class="line">    const desc = Object.getOwnPropertyDescriptors(terget.prototype);</span><br><span class="line">    </span><br><span class="line">    for (const key of Object.key(desc) ) &#123;</span><br><span class="line">        if(key === &apos;contstructor&apos;) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const func = desc[key].value;</span><br><span class="line">        if(typeof func === &apos;function&apos;)&#123;</span><br><span class="line">            Object.defineProperty(terget.prototype,key,&#123;</span><br><span class="line">                value(...args)&#123;</span><br><span class="line">                    console.log(&apos;before&apos;+key);</span><br><span class="line">                    const ret = func.apply(this,args);</span><br><span class="line">                    console.log(&apos;after&apos;+key);</span><br><span class="line">                    </span><br><span class="line">                    return ret;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@log</span><br><span class="line">class Numberic()&#123;</span><br><span class="line">    PI = 3.14</span><br><span class="line">    </span><br><span class="line">    add(...nums)&#123;</span><br><span class="line">        return nums.reduce((p,n) =&gt; (p+n),0)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-对一个类的方法进行参数的验证，同时设置一个类的属性只能是只读。"><a href="#练习2-对一个类的方法进行参数的验证，同时设置一个类的属性只能是只读。" class="headerlink" title="练习2 对一个类的方法进行参数的验证，同时设置一个类的属性只能是只读。"></a>练习2 对一个类的方法进行参数的验证，同时设置一个类的属性只能是只读。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function readOnly(terget,name,descriptor)&#123;</span><br><span class="line">    descriptor.writable = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validate(terget,name,descriptor)&#123;</span><br><span class="line">    const func = descriptor.value;</span><br><span class="line">    descriptor.value = function(...args)&#123;</span><br><span class="line">        for(let num of args)&#123;</span><br><span class="line">            if(typeOf num !== &apos;number&apos;)&#123;</span><br><span class="line">                return new Error(`$&#123;num&#125; is not a number `)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return func.apply(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Numberic()&#123;</span><br><span class="line">    @readOnly</span><br><span class="line">    PI = 3.14</span><br><span class="line">    </span><br><span class="line">    @validate</span><br><span class="line">    add(...nums)&#123;</span><br><span class="line">        return nums.reduce((p,n) =&gt; (p+n),0)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex全家桶总结</title>
      <link href="/2019/11/20/2019/11/vuex%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/20/2019/11/vuex%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="vuex全家桶总结"><a href="#vuex全家桶总结" class="headerlink" title="vuex全家桶总结"></a>vuex全家桶总结</h3><h4 id="Vue脚手架引入store"><a href="#Vue脚手架引入store" class="headerlink" title="Vue脚手架引入store"></a>Vue脚手架引入store</h4><ol><li>利用npm包管理工具，进行安装 vuex。在控制命令行中输入下边的命令就可以了。<br>npm install vuex –save<br>要注意的是这里一定要加上 –save，因为你这个包我们在生产环境中是要使用的。</li><li>一个store文件夹，并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>3、使用我们vuex，引入之后用Vue.use进行引用。<br><code>ue.use(Vuex)</code><br>通过这三步的操作，vuex就算引用成功了，接下来我们就可以尽情的玩耍了。</p><p>4、在main.js 中引入新建的vuex文件<br><code>mport store from &#39;./store/store&#39;</code></p><p>5、再然后 , 在实例化 Vue对象时加入 store 对象 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> el: <span class="string">'#app'</span>,</span><br><span class="line"> router,</span><br><span class="line"> store,</span><br><span class="line"> components: &#123; App &#125;,</span><br><span class="line"> template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="基本结构介绍"><a href="#基本结构介绍" class="headerlink" title="基本结构介绍"></a>基本结构介绍</h4><ol><li>State</li></ol><ul><li>单一状态树，保存项目状态唯一数据源</li><li>通过 this.$store.state 直接访问</li><li>mapState 辅助函数</li></ul><ol start="2"><li>Getter</li></ol><ul><li>定义 getter 方法</li><li>暴露出 store.getters 对象供访问</li><li>mapGetters 辅助函数</li></ul><ol start="3"><li>Mutation</li></ol><ul><li>更改 store 数据</li><li>定义 matations 方法，通过 this.$store.commit() 调用</li><li>Mutation 必须是同步函数</li><li>mapMutations 辅助函数</li></ul><ol start="4"><li>Action</li></ol><ul><li>通过调用 mutation 函数实现更新状态，但不能直接更新状态</li><li>可以包含异步操作</li><li>通过 this.$store.dispatch() 调用</li><li>结合 Promise 使用，实现组合 action</li><li>mapActions 辅助函数</li></ul><ol start="5"><li>Module</li></ol><ul><li>模块化状态，对每个模块添加命名空间</li><li>通过辅助函数调用，调用getter,mutation,action方法前添加命名空间</li></ul><p>参考文章</p><p><a href="https://blog.csdn.net/ywl570717586/article/details/80136455" target="_blank" rel="noopener">非常全面的vuex—-mutation和action的基本使用方法</a></p><p><a href="https://segmentfault.com/a/1190000015782272" target="_blank" rel="noopener">VueJS中学习使用Vuex详解</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue和react的css的模块化</title>
      <link href="/2019/11/17/2019/11/vue%E5%92%8Creact%E7%9A%84css%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/11/17/2019/11/vue%E5%92%8Creact%E7%9A%84css%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="vue中的css-模块化"><a href="#vue中的css-模块化" class="headerlink" title="vue中的css 模块化"></a>vue中的css 模块化</h3><h4 id="style-scope"><a href="#style-scope" class="headerlink" title="style scope"></a>style scope</h4><p>在vue的组件中如果<style scope></style>加上了scope，表明该标签里面写的样式都只作用在当前的页面，加上scope后，会自动添加一个唯一的属性，来确定该css样式作用的范围。<br>比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译渲染后的结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.example[data-v-f3f3eg9] &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span> <span class="attr">data-v-f3f3eg9</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们要编写全局样式的时候，或者要覆盖掉当前组件的样式的时候，不添加scope就可以做到。</p><blockquote><p>在一个 .vue 文件中可以写多个style 来做到样式的区分开。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">/* global styles */</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">/* local styles */</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在vue中使用css-modules"><a href="#在vue中使用css-modules" class="headerlink" title="在vue中使用css modules"></a>在vue中使用css modules</h4><p>在vue中使用css modules 只需要将scope 换成module <code>&lt;style module&gt;&lt;/style&gt;</code>，同时在css-loader中需要配置</p><p>css-loader关于CSS modules的默认配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: true,</span><br><span class="line">  importLoaders: 1,</span><br><span class="line">  localIdentName: &apos;[hash:base64]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用vue-loader的cssModules选项为css-loader进行自定义的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &apos;\.vue$&apos;,</span><br><span class="line">      loader: &apos;vue-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cssModules: &#123;</span><br><span class="line">          localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;,</span><br><span class="line">          camelCase: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.cnblogs.com/xiaohuochai/p/8537959.html" target="_blank" rel="noopener">在vue中使用css modules替代scroped</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hookes 学习笔记</title>
      <link href="/2019/11/16/2019/11/React%20hookes/"/>
      <url>/2019/11/16/2019/11/React%20hookes/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="React-hookes"><a href="#React-hookes" class="headerlink" title="React hookes"></a>React hookes</h2><h3 id="基本要求："><a href="#基本要求：" class="headerlink" title="基本要求："></a>基本要求：</h3><ol><li>只能在函数式组件中进行书写</li><li>只能在顶层调用Hooks。不要在循环，条件或嵌套函数中调用Hook。比如在if/eles 中就不能进行书写。</li></ol><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><h4 id="useState-保存组件状态"><a href="#useState-保存组件状态" class="headerlink" title="useState 保存组件状态"></a>useState 保存组件状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//const [age, setAge] = useState(42);</span></span><br><span class="line">  <span class="comment">//const [fruit, setFruit] = useState('banana');</span></span><br><span class="line">  <span class="comment">//const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>useState的参数就是以前state的初始值。</li><li>useState返回的值中第一个参数是以前的state,第二个参数是setState,不过以前我们只有一个state,现在可以自由命名，更直观了，比如上面的age和setAge，fruit和setFruit</li></ul><blockquote><p>值得注意的是 useState 不帮助你处理状态，相较于 setState 非覆盖式更新状态，useState 覆盖式更新状态，需要开发者自己处理逻辑。</p></blockquote><p>参考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">      name: <span class="string">"alife"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Count: &#123;count&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: count - <span class="number">1</span> &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用useState后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [obj, setObject] = useState(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">"alife"</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      Count: &#123;obj.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, <span class="attr">count</span>: obj.count + <span class="number">1</span> &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, <span class="attr">count</span>: obj.count - <span class="number">1</span> &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>从useState的例子可以看出，我们在setObject中<code>{...obj,count:obj.count+1}</code>对其进行了一个全覆盖，相较于 setState是 非覆盖式更新状态，useState覆盖式更新状态，需要我们处理逻辑。</p><h4 id="useEffect-处理副作用"><a href="#useEffect-处理副作用" class="headerlink" title="useEffect 处理副作用"></a>useEffect 处理副作用</h4><p>为了直观的看出useEffect的用法和作用，我们将下面的例子改成用hooks的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: count + <span class="number">1</span></span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentWillUnmount"</span>;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Count:&#123;count&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; clearInterval(<span class="keyword">this</span>.timer)&#125;&gt;clear&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例子中，组件每隔一秒更新组件状态，并且每次触发更新都会触发 document.title 的更新(副作用)，而在组件卸载时修改 document.title（类似于清除）</p><p>从例子中可以看到，一些重复的功能开发者需要在 componentDidMount 和 componentDidUpdate 重复编写，而如果使用 useEffect 则完全不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">  &#125;,[count]);</span><br><span class="line"> </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"componentWillUnmount"</span>;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; clearInterval(timer)&#125;&gt;clear&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的例子用使用 useEffect 重写了上面的例子，useEffect 第一个参数传递函数，可以用来做一些副作用比如异步请求，修改外部参数等行为，而第二个参数是个数组，如果数组中的值改变才会触发 useEffect 第一个参数中的函数。返回值(如果有)则在组件销毁或者调用函数前调用。</p><ol><li>比如第一个 useEffect 中，理解起来就是一旦 count 值发生改变，则修改 documen.title 值</li><li>而第二个 useEffect 中数组没有传值，代表不监听任何参数变化，即只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount</li></ol><p>参考文章：</p><p><a href="https://lindongzhou.com/article/learn-react-hooks" target="_blank" rel="noopener">十个案例学会 React Hooks</a></p><p><a href="https://zhuanlan.zhihu.com/p/48264713" target="_blank" rel="noopener">对React Hooks的一些思考</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记和总结 </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于一个项目多个环境的问题理解和解决办法</title>
      <link href="/2019/11/16/2019/11/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/11/16/2019/11/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>问题：由于项目有多个环境（uat,dev,stg1,stg2）,现在的需求是更具不同的环境，要控制页面上一个按钮的显示和隐藏。</p><p>问题分析和处理：<br>本地通过在yarn dev 命令里面通过传入不同的参数，然后页面通过js获取到不同环境的参数： 比如在开发环境中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;cross-env BASE_PATH=/ PLATFORM_VERSION=OP CLIENT_ID=localhost BPM_HOST=http://256.000.00.127:8170 API_HOST=http://256.000.00.127:8080 WEBSOCKET_HOST=ws:/256.000.00.127:8120 SRC_WEBSOCKET_URL=http://256.000.00.127:8500 node --max_old_space_size=4196 scripts/start.js&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env BASE_PATH=/ PLATFORM_VERSION=SAAS CLIENT_ID=gjoy-front-dev BPM_HOST=http://256.000.00.127:8170 API_HOST=http://256.000.00.127:8080 WEBSOCKET_HOST=http://256.000.00.127:8120 SRC_WEBSOCKET_URL=http://256.000.00.127:8500 node --max_old_space_size=8196 scripts/start.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;npm run lint:fix &amp;&amp; cross-env BASE_PATH=/ WEBSOCKET_HOST=BUILD_WEBSOCKET_HOST BPM_HOST=BUILD_BPM_HOST CLIENT_ID=BUILD_CLIENT_ID API_HOST=BUILD_API_HOST GENERATE_SOURCEMAP=false node --max_old_space_size=4196 scripts/build.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>脚本涵义：<br>cross-env 运行跨平台设置和使用环境变量的脚本，（npm i –save-dev cross-env 安装使用）<br>dev、 build分别表示开发环境和线上环境<br>CLIENT_ID： 对应的值就是gjoy-front-dev<br>BPM_HOST: 对应的值为<a href="http://192.168.16.172:8170" target="_blank" rel="noopener">http://192.168.16.172:8170</a><br>总之： 等号前面就是参数的名字，后面就是参数的值。<br>在页面上就可以通过： process.env.xxx 来获取对应参数的值</p><ol><li>最简单的解决方式： 在不同的环境中 设置不同的环境变量，然后在jenkins构建的时候 不同的环境执行不同的命令就可以了。<br>比如：<br>uat环境构建的时候 ： 设置CLIENT_ID为project_name_uat<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build:uat: &quot;npm run lint:fix &amp;&amp; cross-env CLIENT_ID=project_name_uat  node --max_old_space_size=4196 scripts/build.js&quot;</span><br></pre></td></tr></table></figure></li></ol><p>dev环境构建的时候 ： 设置CLIENT_ID为project_name_dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build:dev: &quot;npm run lint:fix &amp;&amp; cross-env CLIENT_ID=project_name_uat  node --max_old_space_size=4196 scripts/build.js&quot;</span><br></pre></td></tr></table></figure><p>stg环境构建的时候 ： 设置CLIENT_ID为project_name_stg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build:stg: &quot;npm run lint:fix &amp;&amp; cross-env CLIENT_ID=project_name_uat  node --max_old_space_size=4196 scripts/build.js&quot;</span><br></pre></td></tr></table></figure><p>这种方式：就是要在package.json中的scirpt中要写不同环境的不同命令。</p><p>但是在jenkins中写死了构建的时候调用的时候 <code>yarn build</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;npm run lint:fix &amp;&amp; cross-env BASE_PATH=/ WEBSOCKET_HOST=BUILD_WEBSOCKET_HOST BPM_HOST=BUILD_BPM_HOST CLIENT_ID=BUILD_CLIENT_ID API_HOST=BUILD_API_HOST GENERATE_SOURCEMAP=false node --max_old_space_size=4196 scripts/build.js&quot;,</span><br></pre></td></tr></table></figure><p>这个命令，且他们不想在修改构建命令中指令。所以另外在构建的时候需要在服务器中跑sh脚本 将构建完成的代码中使用到这个环境变量的地方，批量替换了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/gjoy/apps/hces-front</span><br><span class="line">#git reset --hard</span><br><span class="line">git pull</span><br><span class="line">export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 #macos/linux</span><br><span class="line">#rm -rf ./node_modules</span><br><span class="line">#rm -rf ./yarn.lock</span><br><span class="line">#安装依赖 </span><br><span class="line">#yarn add choerodon-ui --registry=http://nexus.saas.hand-china.com/content/groups/hzero-npm-group/ -W -flag</span><br><span class="line">yarn bootstrap</span><br><span class="line">#编译子模块</span><br><span class="line">lerna run transpile</span><br><span class="line">#打包dll </span><br><span class="line">yarn build:dll</span><br><span class="line"># 构建</span><br><span class="line">yarn build</span><br><span class="line">cd /usr/share/nginx/html/gjoy/</span><br><span class="line">rm -rf dist</span><br><span class="line">cp -r /opt/gjoy/apps/hces-front/dist .</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>setup.sh </p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记和总结 </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/2019/11/14/2019/11/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/14/2019/11/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol><li>安装 Node</li><li>安装 Git</li><li>注册码云</li><li>安装 Hexo</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><ul><li>出现下图表示安装成功</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/933c7992797c0f0fs.png" alt></p><h2 id="搭建本地个人博客"><a href="#搭建本地个人博客" class="headerlink" title="搭建本地个人博客"></a>搭建本地个人博客</h2><h3 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h3><ul><li>新建一个空白文件夹（下文提到的“项目根目录”是指你新建的文件夹的位置）用于存放 hexo 资源。在空白文件夹里面打开 Git Bash ，输入下列命令行进行初始化，初始化成功后会在文件夹生成如下图的文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/2454d988bda5f01es.png" alt></p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>关闭本地服务器在 Git Bash 界面按 Ctrl+C， 在浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/ecc250d77459285bs.png" alt></p><h2 id="美化个人博客"><a href="#美化个人博客" class="headerlink" title="美化个人博客"></a>美化个人博客</h2><h3 id="博客主题设置"><a href="#博客主题设置" class="headerlink" title="博客主题设置"></a>博客主题设置</h3><h4 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h4><ul><li>在项目根目录下的 themes 文件中，打开 Git Bash ，用命令行克隆下新的主题。我这里用的 Next 主题，需要其他主题的自己百度找。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/3e09b4d14b279371s.png" alt></p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul><li>用文本的方式打开项目根目录下的 _config.yml 配置文件，找到 theme 把原来默认的 landscape 主题名字，改成刚刚克隆的主题名字（主题名字为上图中文件夹的名字）。</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/7a032ed5279bfee2s.png" alt></p><h3 id="测试主题"><a href="#测试主题" class="headerlink" title="测试主题"></a>测试主题</h3><ul><li>重新回到项目根目录下，打开 Git Bath ，用命令行启动服务器。在浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/51e4059c599bbd2fs.png" alt></p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><ul><li>方法一：在项目根目录下，打开 Git Bash ，执行新建命令，然后 hexo 会自动在指定目录下生成对应文件，如下图所示。然后找到新建好的文件，打开即可进行编辑。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;此处输入文章名字&quot;</span><br></pre></td></tr></table></figure><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/596fc4a69978bed5s.png" alt></p><ul><li>方法二：可以直接把已经准备的 md 格式的文章复制到 项目名称 /source/_posts 目录下，然后打开文件，在文件头加入 front-matter 部分，title 表示文章标题，date 表示发布时间。如图所示，图片上用到的其他参数，后面会介绍到。</li></ul><blockquote><p>front-matte 书写的时候要注意，冒号后面要跟一个空格号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: a</span><br><span class="line">date: 2019-04-14 23:10:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/e9512a34d0ffddaas.png" alt></p><ul><li>准备好 md 格式文件后，使用下面命令生成网站静态文件到默认设置的 public 文件夹，然后再启动本地服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ul><h3 id="主题风格设置"><a href="#主题风格设置" class="headerlink" title="主题风格设置"></a>主题风格设置</h3><ul><li><p>打开主题文件夹下的 _config.yml 配置文件（注意：这里要区别，不是項目根目录，主题文件夹的路径为：新建空白文件夹名称/themes/主题文件夹名称）。通过查找功能找到 Schemes 模块，修改为 Gemini 风格。如果喜欢其他风格可以自己修改。如下图所示：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/57735b310de44a59s.png" alt></p></li><li><p>刷新页面可以看到新风格的界面如下图所示：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/a17bbca793681dbes.png" alt></p></li></ul><h3 id="博客左侧栏设置"><a href="#博客左侧栏设置" class="headerlink" title="博客左侧栏设置"></a>博客左侧栏设置</h3><ul><li>在上面的网站界面，可以发现网站的文字是英文，只要修改一下语言模式即可。打开根目录文件夹下的 _config.yml 配置文件。找到 language，设置为 zh-CN。标题等其他参数的设置如下。可以对照效果图的具体位置，根据自己的实际需求进行修改。（注意：修改了项目根目录下的 _config.yml配置文件，需要重启部署项目后才能生效）</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/cf7f8b7318ba13aes.png" alt><br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/89e91ba175bfc5d7s.png" alt><br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/89e91ba175bfc5d7s.png" alt></p><h3 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h3><h4 id="添加分类列表"><a href="#添加分类列表" class="headerlink" title="添加分类列表"></a>添加分类列表</h4><ul><li>在项目根目录下，执行下面的命令行，新建分类页面，然后会在项目根目录下的 source 文件夹中新建一个 categories 文件夹。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/ec8bf34d15fb441es.png" alt></p><ul><li>打开 categories 文件夹中的 index.md 文件，添加 type 字段，设置为 “categories”。如下图所示。</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/8b72d1e4839a457fs.png" alt></p><ul><li>接着到主题文件夹下的 _config.yml 配置文件下，找到 menu 模块，把 categories 的注释给去掉。如下图所示。</li></ul><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/3205c65c02e1d02cs.png" alt></p><ul><li>刷新页面（如果刷新没效果，可以重启服务），可以在页面左侧栏上看到多了一个“分类”列表。</li><li><img src="http://zwd.yyzheng.cn/hexo_manong_blog/3c0bcb4e00b69674s.png" alt></li></ul><h4 id="如何将文章添加到对应分类？"><a href="#如何将文章添加到对应分类？" class="headerlink" title="如何将文章添加到对应分类？"></a>如何将文章添加到对应分类？</h4><ul><li>文章发布前，在 front-matter 部分，多写一个 categories 字段，然后参数写上类别的名称，保存后重启服务，在网页上点击“分类”，可以看到分类下已经生成了刚刚设置的类别，并把刚刚发布的文章归类在此类别下。如下图所示。<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/9c256cae759cdcffs.png" alt></li></ul><h3 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h3><ul><li>方法跟分类设置一样，所以不再赘述介绍</li><li>但是需要补充一点， front-matter 中字段有多个参数的时候，可以使用如下图的写法。<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/7f1dc337505102c6s.png" alt></li></ul><h3 id="Hexo-博客添加站内搜索"><a href="#Hexo-博客添加站内搜索" class="headerlink" title="Hexo 博客添加站内搜索"></a>Hexo 博客添加站内搜索</h3><ul><li><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍 Local Search 的安装吧。注意：安装的时候要是项目根目录下安装。</p></li><li><p>安装 hexo-generator-search</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li><li><p>安装 hexo-generator-searchdb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下的 _config.yml 配置文件的文末添加下面这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑主题文件夹的 _config.yml 配置文件，设置 Local searchenable 为 ture。<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/7c51e609df9e5c42s.png" alt></p></li><li><p>重启服务，效果图如下：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/f92ee473a8c701cds.png" alt></p></li></ul><h3 id="博客头像设置"><a href="#博客头像设置" class="headerlink" title="博客头像设置"></a>博客头像设置</h3><h4 id="添加博客头像"><a href="#添加博客头像" class="headerlink" title="添加博客头像"></a>添加博客头像</h4><ul><li>打开主题文件夹下的 _config.yml 配置文件，通过查找功能找到 avatar，然后把一个在线的头像图片地址（百度图片中直接复制链接即可），作为 url 的参数。如下图所示：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/a0137663728e3f0fs.png" alt></li><li>然后刷新页面，可以看到网站上已经显示了相应的头像了：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/c8ee1492e43b626as.png" alt></li></ul><h4 id="设置头像圆角并旋转打开"><a href="#设置头像圆角并旋转打开" class="headerlink" title="设置头像圆角并旋转打开"></a>设置头像圆角并旋转打开</h4><ul><li><p>打开主题文件夹的 source\css_common\components\sidebar 目录下的 sidebar-author.styl 文件，然后把下面的代码添加进去即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>效果图如下：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/0a14468ce0d901d9.gif" alt></p></li></ul><h3 id="网页背景设置"><a href="#网页背景设置" class="headerlink" title="网页背景设置"></a>网页背景设置</h3><ul><li>打开主题文件夹下的 source 文件夹，进入 css/_custom 文件下，用文本形式打开 custom.styl 文件，然后添加下面这段代码。代码中 url 的地址是指到： 主题文件夹/source/images/ 。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(/images/bg.jpg);</span><br><span class="line">    <span class="attribute">background-size</span>:cover;</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:center;</span><br><span class="line">    // 设置主题部分的透明度，具体看图</span><br><span class="line">    <span class="selector-tag">opacity</span>: 0<span class="selector-class">.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>效果图如下：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/3d0102f69054f0e6s.png" alt></p><h3 id="首页文章预览设置"><a href="#首页文章预览设置" class="headerlink" title="首页文章预览设置"></a>首页文章预览设置</h3><ul><li><p>默认情况下，文章在首页是全文显示的，这样肯定是不方便读者浏览。所以需要实现预览模式。效果图如下：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/5e832db322ee611es.png" alt></p></li><li><p>方法一：使用 &lt; !–more–&gt; 手动切断</p></li></ul><p>这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。</p><ul><li>方法二：添加 description</li></ul><p>在文章的 front-matter 中添加 description 和 photos 字段，如下图所示。如果不需要显示图片的话，可以把 photos 去掉。<br>ps：不知道 front-matter 是什么的话，跳转到第二章的第4点的发布文章看下。<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/df10c8fb9de7b7b8s.png" alt></p><ul><li>方法三：自动形成摘要</li></ul><p>在主题文件下的_config.yml配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定。</p><h3 id="设置网站图片-Favicon"><a href="#设置网站图片-Favicon" class="headerlink" title="设置网站图片 Favicon"></a>设置网站图片 Favicon</h3><ul><li>在 阿里巴巴矢量图标库 中找到自己的喜欢的图标，下载下来，覆盖掉主题文件夹下的 source/images 目录里面的三张图片即可。<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/c4e5e945c3a1c0d5s.png" alt></li></ul><h3 id="网页顶部进度加载条设置"><a href="#网页顶部进度加载条设置" class="headerlink" title="网页顶部进度加载条设置"></a>网页顶部进度加载条设置</h3><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/00fc9d55b074d32es.png" alt></p><h3 id="博客置顶设置"><a href="#博客置顶设置" class="headerlink" title="博客置顶设置"></a>博客置顶设置</h3><ul><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li><li><p>然后在需要置顶的文章的 Front-matter 中加上 top 即可，数值越大表示等级越高，越靠前显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: this is my first blog</span><br><span class="line">date: 2019-04-14</span><br><span class="line">top: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul><p>-在主题文件夹中打开 layout/_macro/post.swig 文件，定位到 post-header ，把下面的代码添加进去即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zwd.yyzheng.cn/hexo_manong_blog/8b095f7c592707bas.png" alt></p><ul><li>重启服务，效果图如下：<br><img src="http://zwd.yyzheng.cn/hexo_manong_blog/51bfdaba5f3841a0s.png" alt></li></ul><p>参考文章：</p><ul><li><a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/" target="_blank" rel="noopener">码云+Hexo搭建个人博客+评论功能接入</a></li><li><a href="https://www.jianshu.com/p/3fe88ef479dd" target="_blank" rel="noopener">Hexo+Next 添加菜单分类页面</a></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a></li><li><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a></li><li><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661465" target="_blank" rel="noopener">利用Hexo将博客部署到GitPages和CodingPages</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记和总结 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React context基本用法总结</title>
      <link href="/2019/11/14/2019/11/React%20context%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/14/2019/11/React%20context%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Context</code>被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。</p><p>在<code>React</code>的官方文档中，<code>Context</code>被归类为高级部分<code>(Advanced)</code>，属于React的高级API，但官方并不建议在稳定版的App中使用<code>Contex</code>。</p><p>不过，这并非意味着我们不需要关注<code>Context</code>。事实上，很多优秀的<code>React</code>组件都通过<code>Context</code>来完成自己的功能，比如<code>react-redux的&lt;Provider /&gt;</code>，就是通过<code>Context</code>提供一个全局态的<code>store</code>，拖拽组件r<code>eact-dnd</code>，通过<code>Context</code>在组件中分发<code>DOM</code>的<code>Drag</code>和<code>Drop</code>事件，路由组件<code>react-router</code>通过<code>Context</code>管理路由状态等等。在React组件开发中，如果用好Context，可以让你的组件变得强大，而且灵活。</p><h3 id="初识React-Context"><a href="#初识React-Context" class="headerlink" title="初识React Context"></a>初识React Context</h3><p>当你不想在组件树中通过逐层传递<code>props</code>或者<code>state</code>的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。<br><img src="https://upload-images.jianshu.io/upload_images/1457831-b19e007758f57df7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt><br>使用<code>props</code>或者<code>state</code>传递数据，数据自顶下流。<br><img src="https://upload-images.jianshu.io/upload_images/1457831-1b8e3c5ce88f7758?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt><br>使用Context，可以跨越组件进行数据传递。</p><h3 id="如何使用Context"><a href="#如何使用Context" class="headerlink" title="如何使用Context"></a>如何使用Context</h3><p>如果要Context发挥作用，需要用到两种组件，一个是<code>Context生产者(Provider)</code>，通常是一个父节点，另外是一个<code>Context的消费者(Consumer)</code>，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。</p><p>对于父组件，也就是Context生产者，需要通过一个静态属性<code>childContextTypes</code>声明提供给子组件的Context对象的属性，并实现一个实例g<code>etChildContext</code>方法，返回一个代表Context的纯对象 (plain object) 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">class MiddleComponent extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;ChildComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParentComponent extends React.Component &#123;</span><br><span class="line">  // 声明Context对象属性</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string,</span><br><span class="line">    methodA: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 返回Context对象，方法名是约定好的</span><br><span class="line">  getChildContext () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      propA: &apos;propA&apos;,</span><br><span class="line">      methodA: () =&gt; &apos;methodA&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;MiddleComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于Context的消费者，通过如下方式访问父组件提供的Context。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">class ChildComponent extends React.Component &#123;</span><br><span class="line">  // 声明需要使用的Context属性</span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      propA,</span><br><span class="line">      methodA</span><br><span class="line">    &#125; = this.context</span><br><span class="line">    </span><br><span class="line">    console.log(`context.propA = $&#123;propA&#125;`)  // context.propA = propA</span><br><span class="line">    console.log(`context.methodA = $&#123;methodA&#125;`)  // context.methodA = undefined</span><br><span class="line">    </span><br><span class="line">    return ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件需要通过一个静态属性<code>contextTypes</code>声明后，才能访问父组件<code>Context</code>对象的属性，否则，即使属性名没写错，拿到的对象也是<code>undefined</code>。</p><p>对于无状态子组件(Stateless Component)，可以通过如下方式访问父组件的Context</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">const ChildComponent = (props, context) =&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    propA</span><br><span class="line">  &#125; = context</span><br><span class="line">    </span><br><span class="line">  console.log(`context.propA = $&#123;propA&#125;`)  // context.propA = propA</span><br><span class="line">    </span><br><span class="line">  return ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ChildComponent.contextProps = &#123;</span><br><span class="line">  propA: PropTypes.string    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在接下来的发行版本中，React对Context的API做了调整，更加明确了生产者消费者模式的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(&#123;</span><br><span class="line">  background: &apos;red&apos;,</span><br><span class="line">  color: &apos;white&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过静态方法<code>React.createContext()</code>创建一个Context对象，这个Context对象包含两个组件，<code>&lt;Provider /&gt;和&lt;Consumer /&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;&#123;background: &apos;green&apos;, color: &apos;white&apos;&#125;&#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;Provider /&gt;</code>的value相当于现在的<code>getChildContext()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Header extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Title&gt;Hello React Context API&lt;/Title&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Title extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          &lt;h1 style=&#123;&#123;background: context.background, color: context.color&#125;&#125;&gt;</span><br><span class="line">            &#123;this.props.children&#125;</span><br><span class="line">          &lt;/h1&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;Consumer /&gt;</code>的children必须是一个函数，通过函数的参数获取<code>&lt;Provider /&gt;提供的Context</code>。<br>可见，Context的新API更加贴近React的风格。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>React的context就是一个全局变量，可以从根组件跨级别在React的组件中传递。React context 的API 有两个版本,React16.x 之前 的是老版本的 context，之后的是新版本的context。</p><h4 id="1-老版本的context"><a href="#1-老版本的context" class="headerlink" title="1.老版本的context"></a>1.老版本的context</h4><p><code>getChildContext</code>根组件中声明，一个函数，返回一个对象,就是context <code>childContextTyp</code>e根组件中声明,指定context的结构类 型，如不指定,会产生错误<br><code>contextTypes</code>子孙组件中声明，指定要接收的context的结构类型，可以只是context的一部分结构。contextTypes 没有定义，context将是一个空对象。<br><code>this.context</code> 在子孙组件中通过此来获取上下文</p><blockquote><p>(注:从React v15.5开始 ，React.PropTypes 助手函数已被弃用，可使用 prop-types 库 来定义contextTypes)</p></blockquote><p>举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//根组件</span><br><span class="line">class MessageList extends React.Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123;color: &quot;purple&quot;,text: &quot;item text&quot;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const children = this.props.messages.map((message) =&gt;</span><br><span class="line">      &lt;Message text=&#123;message.text&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">    return &lt;div&gt;&#123;children&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageList.childContextTypes = &#123;</span><br><span class="line">  color: React.PropTypes.string</span><br><span class="line">  text: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中间组件</span><br><span class="line">class Message extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MessageItem /&gt;</span><br><span class="line">        &lt;Button&gt;Delete&lt;/Button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//孙组件(接收组件)</span><br><span class="line">class MessageItem extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.context.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageItem.contextTypes = &#123;</span><br><span class="line">  text: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button.contextTypes = &#123;</span><br><span class="line">  color: React.PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-新版本的context"><a href="#2-新版本的context" class="headerlink" title="2.新版本的context"></a>2.新版本的context</h4><p>新版本的React context使用了Provider和Customer模式，和react-redux的模式非常像。在顶层的Provider中传入value，<br>在子孙级的Consumer中获取该值，并且能够传递函数，用来修改context，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//创建Context组件</span><br><span class="line">const ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: &apos;dark&apos;,</span><br><span class="line">  toggle: () =&gt; &#123;&#125;, //向上下文设定一个回调方法</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//运行APP</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.toggle = () =&gt; &#123; //设定toggle方法，会作为context参数传递</span><br><span class="line">      this.setState(state =&gt; (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme === themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggle: this.toggle,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt; //state包含了toggle方法</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中间组件</span><br><span class="line">function Content() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收组件</span><br><span class="line">function Button() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;theme, toggle&#125;) =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggle&#125; //调用回调</span><br><span class="line">          style=&#123;&#123;backgroundColor: theme&#125;&#125;&gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细用法可以参考官方文档：<a href="https://react.docschina.org/docs/context.html#reactcreatecontext" target="_blank" rel="noopener">https://react.docschina.org/docs/context.html#reactcreatecontext</a></p><h4 id="3-context在如下的生命周期钩子中可以使用"><a href="#3-context在如下的生命周期钩子中可以使用" class="headerlink" title="3. context在如下的生命周期钩子中可以使用"></a>3. context在如下的生命周期钩子中可以使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(props, context)</span><br><span class="line">componentWillReceiveProps(nextProps, nextContext)</span><br><span class="line">shouldComponentUpdate(nextProps, nextState, nextContext)</span><br><span class="line">componentWillUpdate(nextProps, nextState, nextContext)</span><br><span class="line">componentDidUpdate(prevProps, prevState, prevContext)</span><br></pre></td></tr></table></figure><h4 id="4-在无状态组件中可以通过参数传入"><a href="#4-在无状态组件中可以通过参数传入" class="headerlink" title="4. 在无状态组件中可以通过参数传入"></a>4. 在无状态组件中可以通过参数传入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function D(props, context) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123;this.context.user.name&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D.contextTypes = &#123;</span><br><span class="line">  user: React.PropTypes.object.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-React-context的局限性"><a href="#5-React-context的局限性" class="headerlink" title="5. React context的局限性"></a>5. React context的局限性</h4><ol><li>在组件树中，如果中间某一个组件 <code>ShouldComponentUpdate returning false</code> 了，会阻碍 context 的正常传值，导致子组件无法获取更新。</li><li>组件本身 <code>extends React.PureComponent</code> 也会阻碍 context 的更新。</li></ol><blockquote><p>注意点：</p><ol><li>Context 应该是唯一不可变的. </li><li>组件只在初始化的时候去获取 Context</li></ol></blockquote><p>参考: </p><ol><li><a href="https://www.tuicool.com/articles/nUryimf" target="_blank" rel="noopener">https://www.tuicool.com/articles/nUryimf</a></li><li><a href="https://segmentfault.com/a/1190000012575622" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012575622</a></li><li><a href="https://www.jianshu.com/p/eba2b76b290b" target="_blank" rel="noopener">https://www.jianshu.com/p/eba2b76b290b</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记和总结 </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise、Generator、Reflect、Map学习笔记</title>
      <link href="/2019/11/14/2019/11/Promise%E3%80%81Generator%E3%80%81Reflect%E3%80%81Map%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/14/2019/11/Promise%E3%80%81Generator%E3%80%81Reflect%E3%80%81Map%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="11-13-学习总结和笔记"><a href="#11-13-学习总结和笔记" class="headerlink" title="11-13 学习总结和笔记"></a>11-13 学习总结和笔记</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ol><li><p>Promise。</p></li><li><p>Generator、Reflect、Map。</p><!--more--><h1 id="Promise、Generator、Reflect、Map学习笔记"><a href="#Promise、Generator、Reflect、Map学习笔记" class="headerlink" title="Promise、Generator、Reflect、Map学习笔记"></a>Promise、Generator、Reflect、Map学习笔记</h1></li></ol><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise的出现是为了解决回调地狱的，使用Promise，我们就可以利用then进行「链式回调」</p><p>构建Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建Promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 异步操作失败 */</span></span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似构建对象，使用new来构建一个Promise。Promise接受一个「函数」作为参数，该函数的两个参数分别是resolve和reject。这两个函数就是就是「回调函数」，由JavaScript引擎提供。</p><p>Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise.then(onFulfilled, onRejected);</span></span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something when success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something when failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都接受Promise对象传出的值作为参数。</p><h3 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h3><p>该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******等同于*******/</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).then(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>promise</code>对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个<code>catch</code>捕获。<code>catch</code>中也能抛错，则需要后面的<code>catch</code>来捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sendRequest(<span class="string">'test.html'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>promise</code>一旦<code>resolve</code>了再抛错，也不会变为<code>rejected</code>，就不会被<code>catch</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'error'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(e);      <span class="comment">//This is never called</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应</p></blockquote><h3 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h3><p>该方法用于将多个Promise实例，包装成一个新的Promise实例。 <code>var p = Promise.all([p1, p2, p3]);</code></p><p>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例</p><p>（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。</p><pre><code>1. 当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数2. 当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">3000</span>, <span class="string">"first"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'second'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">"third"</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(values); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line"><span class="comment">//约 3s 后</span></span><br><span class="line">[<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">"one"</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">  setTimeout(reject, <span class="number">2000</span>, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"three"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject'</span>, error);    <span class="comment">// =&gt; reject three</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line">reject three</span><br></pre></td></tr></table></figure><blockquote><p>这多个 promise 是同时开始、并行执行的，而不是顺序执行</p></blockquote><h3 id="race"><a href="#race" class="headerlink" title=".race()"></a>.race()</h3><p>该方法同样是将多个Promise实例，包装成一个新的Promise实例。<code>var p = Promise.race([p1, p2, p3]);</code></p><p><code>Promise.race</code>方法同样接受一个数组（或具有<code>Iterator</code>接口）作参数。当<code>p1, p2, p3</code>中有一个实例的状态发生改变（变为f<code>ulfilled或rejected</code>），<code>p</code>的状态就跟着改变。并把第一个改变状态的<code>promise</code>的返回值，传给p的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fastPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fastPromise'</span>);</span><br><span class="line">        resolve(<span class="string">'resolve fastPromise'</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> slowPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'slowPromise'</span>);</span><br><span class="line">        resolve(<span class="string">'resolve slowPromise'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第一个promise变为resolve后程序停止</span></span><br><span class="line"><span class="built_in">Promise</span>.race([fastPromise, slowPromise]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; resolve fastPromise</span></span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">fastPromise</span><br><span class="line">resolve fastPromise</span><br><span class="line">slowPromise     <span class="comment">//仍会执行</span></span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title=".resolve()"></a>.resolve()</h3><p>它可以看做new Promise()的快捷方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'Success'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******等同于*******/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'Success'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="它的语法规则"><a href="#它的语法规则" class="headerlink" title="它的语法规则"></a>它的语法规则</h3><p>Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；</p><p>二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p><p>简单实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面函数它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 </p><p>Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个遍历器对象（Iterator Object）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。</p><h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><ul><li><p>yield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。</p></li><li><p>yield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。</p></li><li><p>yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。</p></li></ul><p>而且它只能用在遍历器函数里面,并且它有一个返回值{value: xxx,done: false},value就是当前遍历器暂停时返回</p><p>的结果，done为false得时候，表示遍历器没遍历完，为true表示遍历已结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="keyword">yield</span>(x+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br></pre></td></tr></table></figure><p>遍历器函数一个重要的特点就是需要next()方法才能执行，所以上面f = foo()什么都没发生，要用<code>f.next();</code></p><p><code>f.next()</code>是遍历器第一次执行，当遍历至关键字<code>yield</code>时，函数暂停，并返回yield后面的值，所以此时返回<code>{value: 2,done: false}</code></p><p>再执行一次<code>f.next()</code>,那么遍历器函数则从上次暂停的<code>yield</code>处开始，直接到<code>return</code>语句，所以结果是<code>{value: undefined,done: true}</code></p><p>next()可以接收参数，就是可以将传入的参数作用于上一次yield</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span>(x+y);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = f.next();   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> b = f.next(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> c = f.next(<span class="number">4</span>);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>第一次执行暂停于<code>yield(x+1)</code>,并返回于<code>x+1</code>等于2</p><p>第二次执行，<code>next()</code>的参数<code>2</code>,就代替了上面的<code>yield(x+1)</code>，所以<code>y=2</code>,那么暂停于第二个<code>yield yield(x+y)</code>并返回<code>x+y</code>等于<code>3</code><br>同理,第三次执行<code>z=4，return z</code>等于<code>4</code></p><blockquote><p>注意: next()可以接受一个函数，将函数执行的结果返回 作为其值</p></blockquote><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="为什么要设计Reflect？"><a href="#为什么要设计Reflect？" class="headerlink" title="为什么要设计Reflect？"></a>为什么要设计Reflect？</h3><p>（1）将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。<br>（2）将用 老Object方法 报错的情况，改为返回false</p><p>老写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）让Object操作变成函数行为</p><p>老写法（命令式写法）</p><p><code>&#39;name&#39; in Object //true</code></p><p>新写法</p><p><code>Reflect.has(Object,&#39;name&#39;) //true</code></p><p>（4）Reflect与Proxy是相辅相成的，在Proxy上有的方法，在Reflect就一定有</p><h3 id="Reflect的常用API"><a href="#Reflect的常用API" class="headerlink" title="Reflect的常用API"></a>Reflect的常用API</h3><ol><li>Reflect.get(target,property,receiver)</li></ol><p>与从 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的。</p><p><code>target</code>为需要取值的目标对象，<code>propertyKey</code>需要获取的值的键值，<code>receiver</code>为如果<code>target</code>对象中指定了<code>getter</code>，<code>receiver</code>则为<code>getter</code>调用时的<code>this</code>值。</p><blockquote><p>注意：如果Reflect.get()的第一个参数不是对象，则会报错。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">"x"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="built_in">Reflect</span>.get([<span class="string">"zero"</span>, <span class="string">"one"</span>], <span class="number">1</span>); <span class="comment">// "one"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy with a get handler</span></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">p</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(x, &#123;</span><br><span class="line">  <span class="keyword">get</span>(t, k, r) &#123; <span class="keyword">return</span> k + <span class="string">"bar"</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">"foo"</span>); <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Reflect.set(target,propName,propValue,receiver)</li></ol><p>就像在一个对象上设置一个属性。</p><p><code>target</code>:需要取值的目标对象,<code>propertyKey</code>:需要获取的值的键值,<code>receiver</code>:如果<code>target</code>对象中指定了<code>getter</code>，<code>receiver</code>则为<code>getter</code>调用时的<code>this</code>值。</p><blockquote><p>如果目标值类型不是 Object，则抛出一个 TypeError。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">"prop"</span>, <span class="string">"value"</span>); <span class="comment">// true</span></span><br><span class="line">obj.prop; <span class="comment">// "value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"duck"</span>, <span class="string">"duck"</span>, <span class="string">"duck"</span>];</span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="number">2</span>, <span class="string">"goose"</span>); <span class="comment">// true</span></span><br><span class="line">arr[<span class="number">2</span>]; <span class="comment">// "goose"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It can truncate an array.</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(arr, <span class="string">"length"</span>, <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">arr; <span class="comment">// ["duck"];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With just one argument, propertyKey and value are "undefined".</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, <span class="string">"undefined"</span>);</span><br><span class="line"><span class="comment">// &#123; value: undefined, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Reflect.has()</li></ol><p>作用与 in 操作符 相同。</p><p><code>target</code>目标对象. <code>propertyKey</code>:属性名，需要检查目标对象是否存在此属性。</p><blockquote><p>如果目标对象并非Object 类型，抛出TypeError。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj= &#123;</span><br><span class="line">  name: <span class="string">"chen"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>老写法 <code>&#39;name&#39; in obj // true</code></p><p>新写法<code>Reflect.has(obj, &#39;name&#39;) // true</code></p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/4a5eca0536c3" target="_blank" rel="noopener">ES6之Reflect</a></p><p><a href="https://segmentfault.com/a/1190000010471230" target="_blank" rel="noopener">《深入理解ES6》笔记——代理（Proxy）和反射（Reflection）API（12）</a></p><p><a href="https://blog.csdn.net/u013707249/article/details/78842602" target="_blank" rel="noopener">ES6黑科技实践–proxy,reflect</a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>javascript的Object本身就是键值对的数据结构，但实际上属性和值构成的是”字符串-值“对，属性只能是字符串，如果传个对象字面量作为属性名，那么会默认把对象转换成字符串，结果这个属性名就变成”[object Object]“。</p><p>ES6提供了”值-值“对的数据结构，键名不仅可以是字符串，也可以是对象。它是一个更完善的Hash结构。</p><ol><li>键值对，键可以是对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> objkey = &#123;<span class="attr">p1</span>: <span class="string">'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line">map1.set(objkey, <span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map1.get(objkey))</span><br></pre></td></tr></table></figure></li></ol><p>结果：<code>hello</code></p><ol start="2"><li><p>Map可以接受数组作为参数，数组成员还是一个数组，其中有两个元素，一个表示键一个表示值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'Aissen'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, <span class="number">12</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'name'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'age'</span>))</span><br><span class="line"><span class="string">``</span><span class="string">`      </span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">Aissen</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></li><li><p>size  获取map的大小。</p></li><li><p>get 获取键对应的值。</p></li><li><p>has 判断指定的键是否存在。</p></li><li><p>delete  删除键值对。</p></li><li><p>clear 删除map中的所有键值对</p></li><li><p>set 设置键值对，键可以是各种类型，包括undefined，function。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map4 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map4.set(<span class="string">'k1'</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">map4.set(<span class="number">222</span>, <span class="string">'哈哈哈'</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">map4.set(<span class="literal">undefined</span>, <span class="string">'gagaga'</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>);&#125;</span><br><span class="line">map4.set(fun, <span class="string">'fun'</span>) <span class="comment">// 键是 function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map4 size: %s'</span>, map4.size)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'undefined value: %s'</span>, map4.get(<span class="literal">undefined</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fun value: %s'</span>, map4.get(fun))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map4 size: <span class="number">4</span></span><br><span class="line"><span class="literal">undefined</span> value: gagaga</span><br><span class="line">fun value: fun</span><br></pre></td></tr></table></figure><p>也可对set进行链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map4.set(<span class="string">'k2'</span>, <span class="number">2</span>).set(<span class="string">'k3'</span>, <span class="number">4</span>).set(<span class="string">'k4'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'map4 size: %s'</span>, map4.size)</span><br></pre></td></tr></table></figure><p>结果：<code>map4 size: 7</code></p><p>参考文章<br><a href="https://www.cnblogs.com/kongxianghai/p/7309735.html" target="_blank" rel="noopener">ES6，新增数据结构Map的用法</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Promise原生实现 、 Generator深入学习</title>
      <link href="/2019/11/13/2019/11/ES6%20Promise%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%20%E3%80%81%20Generator%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/13/2019/11/ES6%20Promise%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%20%E3%80%81%20Generator%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="11-13-ES6-Promise原生实现-、-Generator深入学习"><a href="#11-13-ES6-Promise原生实现-、-Generator深入学习" class="headerlink" title="11-13 ES6 Promise原生实现 、 Generator深入学习"></a>11-13 ES6 Promise原生实现 、 Generator深入学习</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ol><li><p>Promise 的局限性。</p></li><li><p>原生实现 、其一些细节。</p></li><li><p>Generator 自执行函数的实现。</p><a id="more"></a></li></ol><p>## </p><h3 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6 Promise"></a>ES6 Promise</h3><h4 id="Promise-的局限性"><a href="#Promise-的局限性" class="headerlink" title="Promise 的局限性"></a>Promise 的局限性</h4><ol><li><strong>错误被吃掉</strong></li></ol><p>首先我们要理解，什么是错误被吃掉，是指错误信息不被打印吗？</p><p>并不是，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">233333</span>);</span><br></pre></td></tr></table></figure><p>在这种情况下，因为 <code>throw error</code>的缘故，代码被阻断执行，并不会打印 233333，再举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">233333</span>);</span><br></pre></td></tr></table></figure><p>以上代码依然会被阻断执行，这是因为如果通过无效的方式使用 <code>Promise</code>，并且出现了一个错误阻碍了正常 <code>Promise</code> 的构造，结果会得到一个立刻跑出的异常，而不是一个被拒绝的 <code>Promise</code>。</p><p>然而再举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2333333</span>);</span><br></pre></td></tr></table></figure><p>这次会正常的打印 <code>233333</code>，说明 <code>Promise</code> 内部的错误不会影响到 <code>Promise</code> 外部的代码，而这种情况我们就通常称为 “吃掉错误”。</p><p>其实这并不是 Promise 独有的局限性，try..catch 也是这样，同样会捕获一个异常并简单的吃掉错误。</p><p>而正是因为错误被吃掉，Promise 链中的错误很容易被忽略掉，这也是为什么会一般推荐在 Promise 链的最后添加一个 catch 函数，因为对于一个没有错误处理函数的 Promise 链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。</p><ol start="2"><li><strong>单一值</strong></li></ol><p>Promise 只能有一个完成值或一个拒绝原因，然而在真实使用的时候，往往需要传递多个值，一般做法都是构造一个对象或数组，然后再传递，then 中获得这个值后，又会进行取值赋值的操作，每次封装和解封都无疑让代码变得笨重。</p><p>说真的，并没有什么好的方法，建议是使用 ES6 的解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>), <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)])</span><br><span class="line">.then(<span class="function">(<span class="params">[x, y]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>无法取消</strong></li></ol><p>Promise 一旦新建它就会立即执行，无法中途取消。</p><ol start="4"><li><strong>无法得知 pending 状态</strong></li></ol><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h3 id="原生实现-、其一些细节"><a href="#原生实现-、其一些细节" class="headerlink" title="原生实现 、其一些细节"></a>原生实现 、其一些细节</h3><ol><li><code>Promise</code> 构造器中必须传入函数，否则会抛出错误。</li></ol><p>2.<code>Promise.prototype</code>上的 <code>catch(onrejected)</code>方法是 <code>then(null,onrejected)</code> 的别名,并且会处理链之前的任何的<code>reject</code>。</p><ol start="3"><li><p><code>Promise.prototype</code> 上的 <code>then和 catch</code> 方法总会返回一个全新的 <code>Promise</code> 对象。</p></li><li><p>如果传入构造器的函数中抛出了错误,该 <code>promise</code> 对象的<code>[[PromiseStatus]]</code>会赋值为 <code>rejected</code>，并且<code>[[PromiseValue]]</code>赋值为 <code>Error</code> 对象。</p></li><li><p><code>then</code>中的回调如果抛出错误，返回的<code>promise</code> 对象的<code>[[PromiseStatus]]</code>会赋值为 <code>rejected</code>，并且 <code>[PromiseValue]]</code>赋值为 <code>Error</code> 对象。</p></li><li><p>t<code>hen</code> 中的回调返回值会影响 <code>then</code> 返回的 <code>promise</code> 对象。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现功能： 自动执行 Generator 返回的 Promise 对象， </span></span><br><span class="line"><span class="comment">//并且将 Promise 的结果在传入到 Generator 进行下一次运行。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span>; <span class="comment">//等待态</span></span><br><span class="line">        <span class="keyword">this</span>.value  = <span class="literal">undefined</span>; <span class="comment">// 表示当前成功的值</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// 表示是失败的值</span></span><br><span class="line">        <span class="keyword">const</span> resolve=<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="comment">// 成功的方法</span></span><br><span class="line">            <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">                self.status = <span class="string">'resolved'</span>;</span><br><span class="line">                self.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="comment">//失败的方法</span></span><br><span class="line">            <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">                self.status = <span class="string">'rejected'</span>;</span><br><span class="line">                self.reason = reason;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line">     then(onFufiled,onRejected) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status !== <span class="string">'pending'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">                    onFufiled(<span class="keyword">this</span>.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">                    onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                &#125;</span><br><span class="line">                clearInterval(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise2(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">       <span class="comment">/* console.log(111);</span></span><br><span class="line"><span class="comment">        resolve();*/</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">3000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我3秒后被输出'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a></p><p><a href="https://segmentfault.com/a/1190000011241512" target="_blank" rel="noopener">解析 Promise 原理，实现一个Promise</a></p><p><a href="https://www.jianshu.com/p/b4f0425b22a1" target="_blank" rel="noopener">Promise原理与实现</a></p><p><a href="https://juejin.im/post/5b66f2935188251afc259f45" target="_blank" rel="noopener">扒一扒PROMISE的原理，大家不要怕！</a></p><h2 id="Generator-自执行函数的实现"><a href="#Generator-自执行函数的实现" class="headerlink" title="Generator 自执行函数的实现"></a>Generator 自执行函数的实现</h2><p>通过下面的代码 了解next、yield 是功能是怎么样的，代码的执行过程是如何的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span>(x+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span>(x+y);</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = f.next();   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> b = f.next(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> c = f.next(<span class="number">4</span>);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>第一次执行暂停于<code>yield(x+1)</code>,并返回于<code>x+1</code>等于2</p><p>第二次执行，<code>next()</code>的参数<code>2</code>,就代替了上面的<code>yield(x+1)</code>，所以<code>y=2</code>,那么暂停于第二个<code>yield yield(x+y)</code>并返回<code>x+y</code>等于<code>3</code><br>同理,第三次执行<code>z=4，return z</code>等于<code>4</code></p><h3 id="单个异步任务"><a href="#单个异步任务" class="headerlink" title="单个异步任务"></a>单个异步任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了获得最终的执行结果，需要这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);<span class="comment">//这里传入的data 相当于 result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="多个异步任务"><a href="#多个异步任务" class="headerlink" title="多个异步任务"></a>多个异步任务</h3><p>只调用了一个接口可以采用上面的那种方式，当我们要调用了多个接口，使用了多个 yield，如果还是采用第一种方式，则会不断的嵌套then. 显而易见的这是不可取的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line">    <span class="keyword">var</span> r3 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/repos'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([r1.bio, r2[<span class="number">0</span>].login, r3[<span class="number">0</span>].full_name].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照第一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result1 = g.next();</span><br><span class="line"></span><br><span class="line">result1.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g.next(data).value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g.next(data).value</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>显然这不是我们想要的： 可以通过递归的方式来减少then的嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.json();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://github.com/mqyqingfeng/Blog/issues/99" target="_blank" rel="noopener">ES6 系列之 Generator 的自动执行</a></p><h3 id="简单原生实现版本co"><a href="#简单原生实现版本co" class="headerlink" title="简单原生实现版本co"></a>简单原生实现版本co</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现功能： 自动执行 Generator 返回的 Promise 对象， 并且将 Promise 的结果在传入到 Generator 进行下一次运行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoRunGen</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = gen();</span><br><span class="line">    result.next().value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result.next(data).value;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">        result.next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参考文章 利用递归*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result2 = result.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result2.done) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result2.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                next(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchStepGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">    <span class="keyword">var</span> jsonData = <span class="keyword">yield</span> result.json();</span><br><span class="line">    <span class="built_in">console</span>.log(jsonData.bio); <span class="comment">// "How people build software."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">autoRunGen(fetchStepGen);</span><br><span class="line">co(fetchStepGen);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基础学习笔记(sass、router、传参方式、keep-Alive  actived和deactived)</title>
      <link href="/2019/09/05/2019/9/vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/05/2019/9/vue%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p> @ 指定到src目录<br>在vue项目中 import 导入文件的时候，@是webpack指定了的别名，默认是指向src目录下。</p></blockquote><h3 id="vue项目配置sass和less"><a href="#vue项目配置sass和less" class="headerlink" title="vue项目配置sass和less"></a>vue项目配置sass和less</h3><p>基于前面创建的工程(用脚手架2.0版本创建的</p><ol><li><p>安装sass的依赖包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev sass-loader </span><br><span class="line"><span class="comment">//sass-loader依赖于node-sass </span></span><br><span class="line">npm install --save-dev node-sass</span><br></pre></td></tr></table></figure></li><li><p>在build文件夹下的webpack.base.conf.js的rules里面添加配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.sass$/</span>, <span class="attr">loaders</span>: [‘style’, ‘css’, ‘sass’] &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，在代码中的 style 标签中 加上<code>lang=&quot;less&quot;</code>属性即可<br><code>&lt;style type=&quot;text/less&quot; lang=”less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;</code></p></li></ol><h3 id="vue-配置router"><a href="#vue-配置router" class="headerlink" title="vue 配置router"></a>vue 配置router</h3><ol><li><p>在路由配置页面引入路由组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></table></figure></li><li><p>然后在该页面配置路由信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Tab <span class="keyword">from</span> <span class="string">'@/views/tab'</span></span><br><span class="line"><span class="keyword">import</span> Contact <span class="keyword">from</span> <span class="string">'@/views/contact'</span></span><br><span class="line"><span class="keyword">import</span> Setting <span class="keyword">from</span> <span class="string">'@/views/setting'</span></span><br><span class="line"><span class="keyword">import</span> Log <span class="keyword">from</span> <span class="string">'@/views/log'</span></span><br><span class="line"><span class="keyword">import</span> One <span class="keyword">from</span> <span class="string">'@/views/setting/children/one'</span></span><br><span class="line"><span class="keyword">import</span> Two <span class="keyword">from</span> <span class="string">'@/views/setting/children/two'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/tab'</span>,</span><br><span class="line">      component: Tab,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/tab/contact'</span>, <span class="attr">component</span>: Contact</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/tab/setting'</span>,</span><br><span class="line">          component: Setting,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              path: <span class="string">'/tab/setting/one'</span>, <span class="attr">component</span>: One, <span class="attr">name</span>: <span class="string">'setting1'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: <span class="string">'/tab/setting/two'</span>, <span class="attr">component</span>: Two, <span class="attr">name</span>: <span class="string">'setting2'</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/log'</span>,</span><br><span class="line">      name: <span class="string">'log'</span>,</span><br><span class="line">      component: Log</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在路由页面引入页面的两种方式的import和require</p></li></ol><p>我们看到是用的require的方式写的路由，所以上面的import就注释掉了，这种写法的好处，不仅仅是简单，还有这样写是按需加载，访问此路由时才加载这个js，会避免进入首页时加载内容过多，因为import引入，当项目打包时路由里的所有component都会打包在一个js中，而用require会将你的component分别打包成不同的js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面是import的方式。</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],() =&gt; r(<span class="built_in">require</span>(<span class="string">'@/views/RouterTest/A.vue'</span>)),<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],() =&gt; r(<span class="built_in">require</span>(<span class="string">'@/views/RouterTest/B.vue'</span>)),<span class="string">'B'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/a'</span>,<span class="attr">name</span>:<span class="string">'A'</span>,<span class="attr">component</span>:A&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/b'</span>,<span class="attr">name</span>:<span class="string">'B'</span>,<span class="attr">component</span>:B&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="vue-路由传参-params-与-query两种方式的区别"><a href="#vue-路由传参-params-与-query两种方式的区别" class="headerlink" title="vue 路由传参 params 与 query两种方式的区别"></a>vue 路由传参 params 与 query两种方式的区别</h4><p>query更加类似于我们ajax中get传参，params则类似于post，前者在浏览器地址栏中显示参数，后者则不显示<br>在页面通过 this.$router.query和this.$router.params获取对应的参数。</p><p>由于params是类似于post传参 所以当页面刷新后，就不能在获取到路由中的参数了。</p><p>比如:下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由关系</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/tab'</span>,</span><br><span class="line">      component: Tab,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/tab/contact'</span>, <span class="attr">component</span>: Contact</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'/tab/setting'</span>,</span><br><span class="line">          component: Setting,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              path: <span class="string">'/tab/setting/one'</span>, <span class="attr">component</span>: One, <span class="attr">name</span>: <span class="string">'setting1'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              path: <span class="string">'/tab/setting/two'</span>, <span class="attr">component</span>: Two, <span class="attr">name</span>: <span class="string">'setting2'</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/log'</span>,</span><br><span class="line">      name: <span class="string">'log'</span>,</span><br><span class="line">      component: Log</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主要路由跳转页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//selete.js</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"setting"</span>&gt;</span><br><span class="line">    Setting</span><br><span class="line"></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"toOne"</span>&gt; to one&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;br&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button @click="toTwo"&gt; to two&lt;/</span>button&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "setting",</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      toOne() &#123;</span></span><br><span class="line"><span class="regexp">        this.$router.push(&#123;</span></span><br><span class="line"><span class="regexp">          name: 'setting1', query: &#123;</span></span><br><span class="line"><span class="regexp">            msg: 'aa'</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      toTwo() &#123;</span></span><br><span class="line"><span class="regexp">        this.$router.push(&#123;</span></span><br><span class="line"><span class="regexp">          name: 'setting2', params: &#123;</span></span><br><span class="line"><span class="regexp">            msg: 'bb'</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>one.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"setting-one"</span>&gt;</span><br><span class="line">    Setting One</span><br><span class="line"></span><br><span class="line">    &lt;button @click=<span class="string">"toLog"</span>&gt;to Log&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "one",</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        msg1: ''</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    created() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('one created')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    activated() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('one activated')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    deactivated() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('one deactivated')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    mounted() &#123;</span></span><br><span class="line"><span class="regexp">      const &#123; msg &#125; = this.$route.query</span></span><br><span class="line"><span class="regexp">      this.msg1 = msg</span></span><br><span class="line"><span class="regexp">      console.log('this.msg1 = ', this.msg1)</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      toLog() &#123;</span></span><br><span class="line"><span class="regexp">        this.$router.push(&#123;</span></span><br><span class="line"><span class="regexp">          name: 'log'</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    destroyed() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('one destroyed')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>two.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"setting-two"</span>&gt;</span><br><span class="line">    Setting Two</span><br><span class="line"></span><br><span class="line">    &lt;button @click=<span class="string">"toLog"</span>&gt;to Log&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    name: "two",</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        msg2: ''</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    created() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('two created')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    mounted() &#123;</span></span><br><span class="line"><span class="regexp">      const &#123; msg &#125; = this.$route.params</span></span><br><span class="line"><span class="regexp">      this.msg2 = msg</span></span><br><span class="line"><span class="regexp">      console.log('this.msg2 = ', this.msg2)</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      toLog() &#123;</span></span><br><span class="line"><span class="regexp">        this.$router.push(&#123;</span></span><br><span class="line"><span class="regexp">          name: 'log'</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    destroyed() &#123;</span></span><br><span class="line"><span class="regexp">      console.log('two destroyed')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>在<code>select.js</code>中两个点击事件可以控制路由的切换，同时两个路由切换的传参方式也不同。当点击<code>toOne()</code>的时候，我们发现<code>ne.js</code>中的<code>onted</code>方法执行了，并且可以得到参数，对应的浏览器地址栏中也显示参数。当刷新页面的时候，还是可以得到参数。</p><p>当点击<code>toTwo()</code>的时候，我们发现<code>wo.js</code>中的<code>monted</code>方法执行了，并且可以得到参数，对应的浏览器地址栏中没有显示参数。当刷新页面的时候，打印参数值为<code>undefined</code>。</p><p>同时在路由进行切换的时候，我们发现都执行了<code>destoryed</code>方法，下次再切换到当前路由的时候<code>created()</code>又会在从新执行。所以这里存在一个小的问题，当我们第一次进入该页面的时候，发送了数据请求。当离开该页面，切换到下一个页面在返回回来的时候，又会从新发送数据请求。这样会造成请求次数的浪费，而且用户的体验也不好。所以采用在<code>&lt;router-view/&gt;</code>外面使用<code>keep-Alive</code>标签。</p><h4 id="keep-Alive-actived和deactived的用法。"><a href="#keep-Alive-actived和deactived的用法。" class="headerlink" title="keep-Alive  actived和deactived的用法。"></a>keep-Alive  actived和deactived的用法。</h4><p>在上面的select.js 中我们通过将kee-Alice包裹起来，然后进行路由跳转的时候发现，切换路由的时候，组件的destoryed方法不再执行，同时当切换回去的时候，create也不再执行，这样就做到了页面不再渲染的效果。</p><p>但是我们的需求就是每次进入页面的时候都要进行请求呢。  keep-Alive 提供了两个方法来代替销毁和创造两个函数，actived和deactived。前一个方法会在进入的页面的时候执行，而后者会在离开的时候执行</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 基础学习</title>
      <link href="/2019/09/05/2019/9/2019_9_8_git%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/05/2019/9/2019_9_8_git%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>项目开发中git是非常重要的，它可以有效、高速地处理从很小到非常大的项目版本管理。</p><a id="more"></a><h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><ul><li>廖雪峰git教程： <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></li><li>git 笔记： <a href="https://github.com/Zhangguoliu/learn-git/blob/master/learngit-note.md" target="_blank" rel="noopener">https://github.com/Zhangguoliu/learn-git/blob/master/learngit-note.md</a></li><li>git 教程： <a href="https://git-scm.com/book/zh/v2/Git-基础-总结" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-总结</a></li><li>git 命令的理解： <a href="https://www.yiibai.com/git/git_fetch.html" target="_blank" rel="noopener">https://www.yiibai.com/git/git_fetch.html</a> </li><li>git 在线学习： <a href="https://learngitbranching.js.org/?demo" target="_blank" rel="noopener">https://learngitbranching.js.org/?demo</a></li><li>了解git flow 协作开发理念 : <a href="https://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnblogsfans/p/5075073.html</a></li></ul><!-- - 了解hzero开发git规范： http://hzerodoc.saas.hand-china.com/zh/docs/development-specification/basic/branch-management/ --><h2 id="项目开发常用命令"><a href="#项目开发常用命令" class="headerlink" title="项目开发常用命令"></a>项目开发常用命令</h2><p>可以设置当前厂库的 用户和邮箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name <span class="string">'xxx'</span>;</span><br><span class="line"></span><br><span class="line">git config --local user.email <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure><p>设置全局的仓库大的用户名和邮箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'xxx'</span>; </span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在github提交代码后如果贡献如果没有被记录，有可能就是你全局或者当前的git仓库的用户名和邮箱不是github的用户名和邮箱。</p></blockquote><p>如果这个命名存在也可以直接覆盖修改,还可以替换git config中已有的邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  git config --global --replace-all user.email &quot;输入你的邮箱&quot;</span><br><span class="line">$  git config --global --replace-all user.name &quot;输入你的用户名&quot;</span><br></pre></td></tr></table></figure><p>保存密码： 如果没有设置ssh 可以通过保存密码的方式来跳过输入密码这个步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper store</span><br></pre></td></tr></table></figure><ul><li><p>git stash: <a href="https://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html" target="_blank" rel="noopener">https://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html</a></p></li><li><p>本地主分支 : <code>origin/HEAD -&gt; origin/master</code>  表示默认分支</p></li><li><p>查看提交详细信息: <code>git show</code></p></li><li><p><code>git  status</code> ：命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被<code>Git tracked</code>到。<code>git status</code>不显示已经<code>commit</code>到项目历史中去的信息。 一般红色的没有被追踪到，绿色的是已经add后的， 意思就是被追踪了</p></li><li><p>克隆指定分支下的内容: <code>clone -b brandName url</code></p></li><li><p>参看所有分支： <code>git branch -a 会列出当前库所有的分支（本地、远程）</code></p></li><li><p>切换分支： <code>git checkout branchName</code> 加上 -b 参数会新建并切换到该分支 <code>git checkout -b branchName</code></p></li><li><p>创建分支：<code>git brahch branchName</code></p></li><li><p>删除分支：<code>git branch --delete branchName</code></p></li><li><p>删除远程分支： <code>git push --delete origin branchName</code></p></li><li><p>删除那些远程仓库不存在的分支: <code>git remote prune origin</code></p></li><li><p>查看本地分支与远程分支的对应关系： <code>git remote show origin</code><br><img src="../../../images/InkedshowOrigin_LI.jpg" alt><br>通过这个命令可以看出 本地分支与远程分支的对应关系，是否与远程有对应关系。</p></li></ul><p><code>Local branches configured for &#39;git pull&#39;</code>:表示本地分支 从哪个远程分支拉取</p><p><code>Local branches configured for &#39;git pull&#39;</code>:表示本地分支 推送到哪个远程分支上去</p><h3 id="git-常用命令理解"><a href="#git-常用命令理解" class="headerlink" title="git 常用命令理解"></a>git 常用命令理解</h3><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>将某个远程主机的更新 <code>git fetch &lt;远程主机名&gt;</code> 若要更新所有分支，命令可以简写为： <code>git fetch</code></p><p>上面命令将某个远程主机的更新，全部取回本地。默认情况下，git fetch取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名,如下所示: <code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></p><p>比如，取回origin主机的master分支： <code>git fetch origin master</code></p><p>所取回的更新，在本地主机上要用<strong>远程主机名/分支名</strong>的形式读取。比如origin主机的master分支，就可以用<code>origin/master</code>读取。</p><p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>上面命令表示，本地主机的当前分支是master，远程分支是<code>origin/master</code>。取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p><h4 id="常见分支操作-新建分支"><a href="#常见分支操作-新建分支" class="headerlink" title="常见分支操作 -新建分支"></a>常见分支操作 -新建分支</h4><h5 id="情况1-："><a href="#情况1-：" class="headerlink" title="情况1 ："></a>情况1 ：</h5><p>如果远程新建了一个分支，本地没有该分支，可以用 <code>git checkout --track origin/branch_name</code></p><p>这时候本地会新建一个分支名叫<code>branch_name</code>，会自动跟踪（track）远程的同名分支branch_name（就可以在这个本地分支上推拉代码）</p><p>用上面中方法，得到的分支名永远和远程的分支名一样，如果想新建一个本地分支不同名字，同时跟踪一个远程分支可以利用。<br><code>git checkout -b new_branch_name branch_name</code></p><p>这条指令本来是根据一个<code>branch_name</code>分支分出一个本地分支<code>new_branch_name</code>，但是如果所根据的分支<code>branch_name</code>是一个远程分支名，那么本地的分支会自动的<code>track</code>远程分支。</p><blockquote><p>注意：一般用<code>git push --set-upstream origin branch_name</code>来在远程创建一个与本地<code>branch_name</code>同名的分支并跟踪；利用<code>git checkout --track origin/branch_name</code>来在本地创建一个与<code>branch_name</code>同名分支跟踪远程分支.</p></blockquote><p>当使用<code>git checkout -b new_branch_name origin/branch_name</code>当提交的时候会报这个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD:master</span><br><span class="line"></span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin dev-test</span><br></pre></td></tr></table></figure><p>这是由于<code>Git</code>中<code>push.default</code>的设置的原因</p><p><code>Git</code>中<code>push.default</code>可以指定在没有明确指定远程分支的情况下，默认push的远程分支，其取值可以是：</p><ul><li><p><code>nothing</code> - <code>push</code> 操作无效，除非显式指定远程分支（意思就是 push的时候 必须指定远程的分支）</p></li><li><p><code>current</code> - <code>push</code> 当前分支到远程<strong>同名</strong>分支，如果远程同名分支不存在则自动创建同名分支（<code>central 和 non-central workflows</code>都适用）</p></li><li><p><code>upstream</code> - <code>push</code> 当前分支到它的<code>upstream</code>分支上（通常用于<code>central workflow</code>）</p></li><li><p><code>simple</code> - <code>simple</code>和<code>upstream</code>是相似的（通常用于<code>central workflow</code>），只有一点不同，<code>simple</code>必须保证本地分支和它的远程<code>upstream</code>分支同名，否则会拒绝<code>push</code>操作</p></li><li><p><code>matching</code> - <code>push</code>所有本地和远程两端都存在的同名分支</p></li><li><p><code>central / non-central workflows</code> 是<code>Git</code>的两种常见工作流场景：</p><ol><li><code>central workflows</code> - 集中式工作流，一个分支的<code>push</code>和<code>pull</code>都是同一个远程仓库</li><li><code>non-central workflows</code> - 非集中式工作流，一个分支的<code>push</code>和<code>pull</code>可能分别都有不同的远程仓库</li></ol></li></ul><blockquote><p>在Git 2.0之前，push.default的内建值被设为’matching’，2.0之后则被更改为了’simple’。</p></blockquote><p>通过<code>git remote show origin</code>可以看到每个分支的具体信息: (例如 <code>git checkout -b local origin/daily/dev</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Local branches configured for &apos;git pull&apos;:</span><br><span class="line">    local merges with remote /daily/dev</span><br><span class="line">    master       merges with remote master</span><br><span class="line"> Local ref configured for &apos;git push&apos;:</span><br><span class="line">   master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>由于<code>git checkout -b local origin/daily/dev</code>会自动创建远程分支<code>/daily/dev</code> 和本地分支local的跟踪关系。<br>其中<code>Local branches configured for &#39;git pull&#39;</code>:下的就是<code>upstream</code>跟踪分支。</p><p>可以看出，远程分支<code>/daily/dev</code>和本地分支<code>local</code>建立了<code>git pull</code>的关系，但是没有建立<code>git push</code>的关系。此时如果强行push，不会成功，会出现如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch new has no upstream branch.  </span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line">    git push --set-upstream origin develop</span><br></pre></td></tr></table></figure><p>这种提示的处理方式下面会给出具体的处理方法。</p><h5 id="情况2-："><a href="#情况2-：" class="headerlink" title="情况2 ："></a>情况2 ：</h5><p>本地新建分支，然后推送到远程，可以使用<code>git branch branch_name</code>或者<code>git checkout -b branch_name</code>(新建并切换到该分支) 新建一个本地分支,然后修改了代码 执行add 、commit、最后执行push操作 发现会发现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># git push </span><br><span class="line">fatal: The current branch make-scripts-executable has no upstream branch.</span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin branch_name</span><br></pre></td></tr></table></figure><p>这是因为Git不知道你要提交到哪个分支上去, 所以需要你指定提交的分支, 直接从本地检出的新分支，第一次push，远程仓库还没有与之建立tracing关系的分支，所以需要设置upstream，这个设置一次之后，后面再push的时候就不用设置了。</p><p>如果不想这样写则需要指定提交到远程的分支： <code>git push origin branch_name</code>。</p><p><code>git push origin branch_name</code>推向制定的分支，最强暴的方法。但是每次提交都要指定，太麻烦了（而且还容易出错）。所以需要与远程分支关联。</p><p>所以使用<code>git push --set-upstream origin branch_name</code>远程分支关联。 这样就不用每次push的时候都指定分支了，都会提交到关联的远程分支上去。(branch_name是远程分支名)</p><h4 id="常见分支操作-合并分支"><a href="#常见分支操作-合并分支" class="headerlink" title="常见分支操作 合并分支"></a>常见分支操作 合并分支</h4><p><code>git merge</code>命令用于将两个或两个以上的开发历史加入(合并)一起。 将 merge 后面的分支合并到当前分支。</p><ul><li><p>将分支dev合并到当前分支中，自动进行新的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure></li><li><p>合并分支 branch1 和 branch2 在当前分支的顶部，使它们合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge branch1 branch2</span><br></pre></td></tr></table></figure></li><li><p>合并branch1分支到当前分支，使用ours合并策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge -s ours branch1</span><br></pre></td></tr></table></figure></li><li><p>将分支branch1合并到当前分支中，但不要自动进行新的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-commit branch1</span><br></pre></td></tr></table></figure></li></ul><h4 id="Git-checkout-文件名-、git-reset-HEAD-文件名-、git-reset-哈希值-的应用场景。"><a href="#Git-checkout-文件名-、git-reset-HEAD-文件名-、git-reset-哈希值-的应用场景。" class="headerlink" title="Git checkout [文件名]、git reset HEAD [文件名] 、git reset [哈希值] 的应用场景。"></a>Git checkout [文件名]、git reset HEAD [文件名] 、git reset [哈希值] 的应用场景。</h4><h5 id="git-reset-HEAD-文件名"><a href="#git-reset-HEAD-文件名" class="headerlink" title="git reset HEAD [文件名]"></a>git reset HEAD [文件名]</h5><p><img src="../../../images/gitAdd.png" alt></p><p>通过git reset [文件名] 可以将暂存区的文件放出来 ， 但是我们的工作区的内容没有改变。只是相当于 对[文件名] 不执行 git add 操作 。 类似于后退操作。</p><h4 id="git-checkout-文件名"><a href="#git-checkout-文件名" class="headerlink" title="git checkout [文件名]"></a>git checkout [文件名]</h4><p>工作区回退：如果比对后，发现这次改动不是我们想要的，那么我们可以回退到未修改之前，（在vsCode等编辑器里面，可以放弃修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout readme.txt</span><br><span class="line">git checkout .</span><br><span class="line">git checkout -- readme.txt  // 以防判断成分支</span><br></pre></td></tr></table></figure><p><img src="../../../images/gitChange.png" alt></p><p>下面这串数字是我们新加的, 通过git status 我们可以看到readme.md文件做了修改</p><p><img src="../../../images/gitChange1.png" alt></p><p>使用 git checkout [文件名] 可以将它变成修改前的是 ，意思就是放弃本次修改。 执行改命令后，发现添加的数字不见了<br>git status 显示文件没有修改。</p><p><img src="../../../images/gitChange2.png" alt></p><p>如果我们已经添加到了暂存区（意思已经执行 <code>git add</code> 操作了），如果要退回到修改前，我们应该怎么处理呢。</p><p>直接通过<code>git checkout [文件名]</code>是不能将它回退到未修改的样子的。可以先采用<code>git reset HEAD [文件名]</code> 将它移除暂存区（意思就是回退在没有执行<code>git add</code> 的时候）, 然后通过<code>git checkout [文件名]</code> 将改文件退回到修改前。</p><h4 id="git-reset-哈希值"><a href="#git-reset-哈希值" class="headerlink" title="git reset [哈希值]"></a>git reset [哈希值]</h4><p>上面的操作都是在暂存区 ，还没有使用git commit 提交到本地厂库 。如果已经提交到本地厂库了又要如何操作呢。</p><p>将readme.md文件添加一段文字, 然后提交到本地的厂库。</p><p><img src="../../../images/gitChange3.png" alt></p><p>通过<code>git reflog</code>可以看到一共有两个版本  当前的版本是<code>HEAD -&gt; master</code></p><p><img src="../../../images/gitReflog.png" alt></p><p>然后 在修改文件<code>readme.md</code>，然后在提交到本地厂库。</p><p><img src="../../../images/gitChange4.png" alt></p><p>但是这个时候的需求是 <strong>回到没有添加第二次提交文字</strong>的时候，意思就是要回到上一个版本。</p><p>可以通过使用 <code>git reset</code> 的命令来完成。基本的流程是执行：<code>git reset --mixed HEAD^</code>意思就是回退到上一个版本。</p><p><img src="../../../images/gitReset1.png" alt></p><p>可以发现命令成功了，是不是页面也变成了原来的样子呢，然后并没有改变。那这个命令具体做了什么呢?</p><p>我们通过看<code>readme.md</code>和<code>git status</code>看可以看到</p><p><img src="../../../images/gitChange5.png" alt><br><img src="../../../images/gitChange6.png" alt></p><p>是将它回退没有执行<code>git add</code>命令之前了，相当于你修改了代码 但是没有提交的那个状态。然后可以通过<code>git checkout readme.md</code> 命令将它变回未修改的状态。</p><p>但是如果我们要从现在没有添加那个文字的这个版本  变到添加了文字的版本 要如何操作呢。</p><p>通过<code>git reflog</code> 可以看出当前的版本是<code>fd8258e</code></p><p><img src="../../../images/gitReset2.png" alt></p><p>我们使用 <code>git reset --hard HEAD^</code>, 发现这里readme.md文件直接被修改了。</p><p><img src="../../../images/gitReset3.png" alt></p><p> 同时版本并灭有从<code>fd8258e</code> 变到 <code>a5da32e</code> 而是变到了<code>df0abb9</code>，这里的原因是git的提交是一条时间线，在这条时间线上，<code>fd82582</code>的上一次提交就是<code>df0abb9</code></p><p><img src="../../../images/gitReset4.png" alt></p><p>如果要变成指定的版本应该采用命令： <code>git reset [哈希值]； --mixed 为默认参数</code>。</p><p><img src="../../../images/gitReset5.png" alt></p><p>显示readme.md被修改了，通过左右两边的比较可以发现。 左边相当于原文件，而右边相当于对原文件的修改。可以通过 <code>git checkout readme.md</code>放弃本次修改。</p><p><img src="../../../images/githash.png" alt></p><p>执行<code>git checkout readme.md</code>页面变成了修改之前的，同时也可以使用<code>git statsu</code>看出没有做出修改。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础学习</title>
      <link href="/2019/09/02/2019/9/2019_9_2_javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/02/2019/9/2019_9_2_javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="7-04-学习总结和笔记"><a href="#7-04-学习总结和笔记" class="headerlink" title="7-04 学习总结和笔记"></a>7-04 学习总结和笔记</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ol><li><p>了解学习计划。</p></li><li><p>与老师探讨学习策略，包括学习内容以及学习方法。</p></li><li><p>探讨以往培训生学习经验，总结新的学习方案。</p><a id="more"></a></li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="chrome开发工具的使用"><a href="#chrome开发工具的使用" class="headerlink" title="chrome开发工具的使用"></a>chrome开发工具的使用</h4><ol><li><p>安装google访问助手插件，建议多用google查找相关问题和资料。 了解翻墙的原理，简单的来讲就是通过访问香港、澳门、台湾的待在的服务器，然后该服务区在通过再去访问国外的服务器，从而实现翻墙操作。个人感觉于服务器代理的原理差不多。</p></li><li><p>elements调样式，Console拿到实例，Network看请求头URL请求方式响应码，请求参数，Sources定位源码，Performance优化，显示渲染时间，Application缓存。</p></li></ol><blockquote><p>注：请求头中常用字段：Authorization，请求体：参数。</p></blockquote><h3 id="js基础学习"><a href="#js基础学习" class="headerlink" title="js基础学习"></a>js基础学习</h3><p>发展历史，基础知识，常见字符串、数组方法，调试技巧</p><p>上下文、闭包、this、apply、call</p><p>原型、原型链继承、项目中的应用</p><p>结合ajax、上传demo讲解、同步异步、post表单类型等</p><h4 id="变量提升和作用域链"><a href="#变量提升和作用域链" class="headerlink" title="变量提升和作用域链"></a>变量提升和作用域链</h4><ol><li>函数作用域和声明提前：JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被提前至函数体的顶部</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></span><br><span class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;          <span class="comment">// 在函数顶部声明了局部变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 变量存在，但其值是"undefined"</span></span><br><span class="line">    scope = <span class="string">"local"</span>;    <span class="comment">// 这里将其初始化并赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 这里它具有了我们所期望的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的前端，始终都是当前执行的代码所在环境的变量对象。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">            anotherColor = color;</span><br><span class="line">            color = tempColor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>静态作用域与动态作用域</p><pre><code>词法作用域：词法作用域是指在词法分析阶段就确定了，不会改变。变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。动态作用域：动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们在何处调用。参考this</code></pre><p>JavaScript的词法作用域是静态作用域</p><p>如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p><ol><li><p>读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的）</p></li><li><p>做词法分析，有错则报语法错误（比如括号不匹配等），并跳转到步骤5</p></li><li><p>对var变量和function定义做“预解析“（永远不会报错的，因为只解析正确的声明）</p></li><li><p>执行代码段，有错则报错（比如变量未定义）</p></li><li><p>如果还有下一个代码段，则读入下一个代码段，重复步骤2</p></li><li><p>完成</p></li></ol><p>理解js词法作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>假设JavaScript采用静态作用域，分析执行过程：</p><p>  执行 foo 函数，先从 foo 函数局部作用域中查找是否有变量 value，如果没有，就从全局作用域中查找变量value的值，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>  执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p><p>参考链接 <a href="https://blog.csdn.net/qq_27626333/article/details/78463565" target="_blank" rel="noopener">JavaScript作用域、上下文、执行期上下文、作用域链、闭包</a></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ol><li>每一个对象都有<strong>proto</strong>属性</li><li>只有函数对象有prototyp属性</li></ol><p><img src="http://image.bubuko.com/info/201601/20180110174710584431.jpg" alt></p><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>slice(start,end)</p><p>subString(start,end) start大于end；开会自动转化</p><p>substr(start,end)</p><p>concat（）返回字符串，链接字符串</p><p>split（）</p><p>replace（）去掉空格</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 学习笔记和总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlogList博客列表</title>
      <link href="/2019/09/01/2019/9/2019_9_1_BlogList%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8/"/>
      <url>/2019/09/01/2019/9/2019_9_1_BlogList%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>一些需要看、了解的文档和博客</p><a id="more"></a><h2 id="不分太细"><a href="#不分太细" class="headerlink" title="不分太细"></a>不分太细</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ol><li><a href="http://hcysun.me/vue-design/art/" target="_blank" rel="noopener">可能是最好的Vue源码解读了</a></li><li><a href="https://react.jokcy.me/" target="_blank" rel="noopener">React源码No1</a></li><li><a href="https://github.com/MuYunyun/blog/tree/master/React/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0React" target="_blank" rel="noopener">最好的react源码实现</a></li><li><a href="https://juejin.im/post/5c0c7304f265da613e22106c" target="_blank" rel="noopener">暂时比较好React的解读</a></li><li><a href="#react源码">react源码</a></li><li><a href="https://leoeatle.github.io/techBlog/2018/08/04/React16%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-As-required-order/" target="_blank" rel="noopener">react16</a></li></ol><h3 id="Preact"><a href="#Preact" class="headerlink" title="Preact"></a>Preact</h3><h4 id="粱少峰-腾讯大佬，有实现简易版preact"><a href="#粱少峰-腾讯大佬，有实现简易版preact" class="headerlink" title="粱少峰 腾讯大佬，有实现简易版preact"></a>粱少峰 腾讯大佬，有实现简易版preact</h4><ol><li><a href="https://github.com/youngwind/blog/issues/103" target="_blank" rel="noopener">这个是最好的preact解读</a></li><li><a href="https://github.com/youngwind/fake-preact/blob/master/preact.js" target="_blank" rel="noopener">简易版例子</a></li></ol><h4 id="大佬都是参考他的"><a href="#大佬都是参考他的" class="headerlink" title="大佬都是参考他的"></a><a href="https://juejin.im/post/59b69b6e5188257e6b6d7bfc" target="_blank" rel="noopener">大佬都是参考他的</a></h4><h4 id="腾讯大佬，分章节好理解"><a href="#腾讯大佬，分章节好理解" class="headerlink" title="腾讯大佬，分章节好理解"></a>腾讯大佬，分章节好理解</h4><ol><li><a href="https://blog.csdn.net/flytam/article/list/2" target="_blank" rel="noopener">https://blog.csdn.net/flytam/article/list/2</a>?</li></ol><h4 id="这个连续性较强"><a href="#这个连续性较强" class="headerlink" title="这个连续性较强"></a>这个连续性较强</h4><ol><li><a href="https://juejin.im/entry/59cbc6cb5188257462038b07" target="_blank" rel="noopener">https://juejin.im/entry/59cbc6cb5188257462038b07</a></li></ol><h4 id="每一行代码都有注释的，特别好"><a href="#每一行代码都有注释的，特别好" class="headerlink" title="每一行代码都有注释的，特别好"></a>每一行代码都有注释的，特别好</h4><ol><li><a href="https://github.com/wangning0/preact_analyse/tree/master/src" target="_blank" rel="noopener">Preact源码注释解析</a></li></ol><h3 id="要看的博客和文章"><a href="#要看的博客和文章" class="headerlink" title="要看的博客和文章"></a>要看的博客和文章</h3><ol><li><a href="https://github.com/MuYunyun/blog#" target="_blank" rel="noopener">深度广度都有的博客</a>第一</li><li><a href="https://juejin.im/user/5b61d0065188251af66240cb/likes" target="_blank" rel="noopener">看我的掘金赞的文章和关注的博主：关联微信</a>：一般关注是文章质量高</li><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question" target="_blank" rel="noopener">木易阳说每天一道面试题</a></li><li><a href="https://github.com/airuikun/Weekly-FE-Interview" target="_blank" rel="noopener">疼迅高级前端每周10道面试题</a></li><li><a href="https://github.com/FrankKai/FrankKai.github.io/issues?page=1&q=is%3Aissue+is%3Aopen" target="_blank" rel="noopener">走在我前面的老哥：学习的榜样，文章大多数都是我刚需的</a></li><li><a href="https://github.com/brickspert/blog/issues/16" target="_blank" rel="noopener">阿里大佬的面经</a></li><li><a href="http://hpoenixf.com/posts/25280/" target="_blank" rel="noopener">也是一个学习清单</a></li><li><a href="https://github.com/youngwind/blog/issues?page=3&q=is%3Aissue+is%3Aopen" target="_blank" rel="noopener">腾讯大佬的笔记</a></li><li><a href="https://github.com/WisestCoder/blog" target="_blank" rel="noopener">一个朴实的大佬</a></li><li><a href="https://github.com/ljianshu/Blog" target="_blank" rel="noopener">一个很全的笔记，Vue</a></li><li><a href="https://yanhaijing.com/" target="_blank" rel="noopener">颜如镜，美团大佬博客</a></li><li><a href="http://luoxia.me/code/" target="_blank" rel="noopener">一个牛逼的大佬, koa源码node,学习他的方向</a></li><li><a href="https://github.com/zhengweikeng/blog/tree/master/posts" target="_blank" rel="noopener">ngnix、docker、算法</a>：拓展学习广度</li><li><a href="https://juejin.im/user/58d8cd0644d9040069433edb/posts" target="_blank" rel="noopener">掘金一个大佬的博客：深克隆、Router、双向绑定</a></li><li><a href="https://github.com/xiyuyizhi/notes" target="_blank" rel="noopener">阿里大佬</a></li><li><a href="https://www.cnblogs.com/rubylouvre/default.html" target="_blank" rel="noopener">很广较深的博主</a></li><li><a href="https://yuchengkai.cn/docs/frontend/" target="_blank" rel="noopener">面试图谱</a>:比较全</li><li><a href="https://github.com/amandakelake/blog" target="_blank" rel="noopener">面试js和网络的小记</a></li><li><a href="https://github.com/stephentian/33-js-concepts" target="_blank" rel="noopener">33个js基础知识点</a></li><li><a href="https://github.com/MrErHu/blog" target="_blank" rel="noopener">js和React可以看看</a></li><li><a href="https://github.com/USTB-musion/fee-skills" target="_blank" rel="noopener">很全的疼迅大佬</a></li><li><a href="https://github.com/GayeChen/blog" target="_blank" rel="noopener">全但是不完整的面经</a></li><li><a href="https://github.com/xitu/front-end-handbook-2018" target="_blank" rel="noopener">前端开发者指南 2018</a></li><li><a href="https://www.cnblogs.com/pssp/p/5782304.html" target="_blank" rel="noopener">人之所以迷茫，就是没有方向，一个方向的参考</a></li><li><a href="https://github.com/hyy1115/Front-end-course" target="_blank" rel="noopener">不是很深：React部分可以参考</a></li></ol><h3 id="JS深入"><a href="#JS深入" class="headerlink" title="JS深入"></a>JS深入</h3><ol><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">汤姆大叔</a></li><li><a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">王福朋</a></li><li><a href="https://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">这个写的很好</a></li></ol><h3 id="react源码"><a href="#react源码" class="headerlink" title="react源码"></a>react源码</h3><ol><li><a href="https://github.com/amandakelake/blog/issues/27" target="_blank" rel="noopener">react源码</a></li><li><a href="http://www.sosout.com/2018/08/12/react-source-analysis.html" target="_blank" rel="noopener">react源码</a></li></ol><h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><ol><li><a href="https://github.com/azl397985856/leetcode?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode?utm_source=gold_browser_extension</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料 </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
